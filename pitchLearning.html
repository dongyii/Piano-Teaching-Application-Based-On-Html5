<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>音高符号学习</title>
    <!--样式-->
    <style>
        body{
            margin:0px;
            overflow: hidden;
        }
    </style>
    <!--引入THREE.js-->
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="OBJLoader.js"></script>
    <script src="MTLLoader.js"></script>
    <script src="myBoxGeometry.js"></script>
    <script src="Bird.js"></script>
    <script src="stats.min.js"></script>
</head>
<body>
<div id="container"></div>

<script>

    // Based on http://www.openprocessing.org/visuals/?visualID=6910

    var Boid = function() {

        var vector = new THREE.Vector3(),
                _acceleration, _width = 500, _height = 500, _depth = 200, _goal, _neighborhoodRadius = 100,
                _maxSpeed = 2, _maxSteerForce = 0.1, _avoidWalls = false;

        this.position = new THREE.Vector3();//位置
        this.velocity = new THREE.Vector3();//速度
        _acceleration = new THREE.Vector3();//加速度

        this.setGoal = function ( target ) {

            _goal = target;

        };
        this.setNeighborhoodRadius = function ( target ) {

            _neighborhoodRadius = target;

        };

        this.setAvoidWalls = function ( value ) {

            _avoidWalls = value;

        };

        this.setWorldSize = function ( width, height, depth ) {

            _width = width;
            _height = height;
            _depth = depth;

        };

        this.run = function ( boids ) {

            if ( _avoidWalls ) {

                vector.set( - _width, this.position.y, this.position.z );//x轴左边的一个位置点 或者说从原点到这个点的向量
                vector = this.avoid( vector );//产生一个远离这个位置点的向量
                vector.multiplyScalar( 5 );//远离的向量的大小乘以5倍
                _acceleration.add( vector );//给加速度加上这个远离向量

                vector.set( _width, this.position.y, this.position.z );
                vector = this.avoid( vector );
                vector.multiplyScalar( 5 );
                _acceleration.add( vector );

                vector.set( this.position.x, - _height, this.position.z );
                vector = this.avoid( vector );
                vector.multiplyScalar( 5 );
                _acceleration.add( vector );

                vector.set( this.position.x, _height, this.position.z );
                vector = this.avoid( vector );
                vector.multiplyScalar( 5 );
                _acceleration.add( vector );

                vector.set( this.position.x, this.position.y, - _depth );
                vector = this.avoid( vector );
                vector.multiplyScalar( 5 );
                _acceleration.add( vector );

                vector.set( this.position.x, this.position.y, _depth );
                vector = this.avoid( vector );
                vector.multiplyScalar( 5 );
                _acceleration.add( vector );

            }/* else {

             this.checkBounds();

             }
             */

            if ( Math.random() > 0.5 ) {

                this.flock( boids );

            }

            this.move();

        };

        this.flock = function ( boids ) {

            if ( _goal ) {

                _acceleration.add( this.reach( _goal, 0.005 ) );//接近目的坐标 向量长度乘以0.005倍

            }

            _acceleration.add( this.alignment( boids ) );
            _acceleration.add( this.cohesion( boids ) );
            _acceleration.add( this.separation( boids ) );

        };

        this.move = function () {

            this.velocity.add( _acceleration );//速度加上加速度

            var l = this.velocity.length();//判断速度的长度

            if ( l > _maxSpeed ) {

                this.velocity.divideScalar( l / _maxSpeed );

            }

            this.position.add( this.velocity );//按照速度移动
            _acceleration.set( 0, 0, 0 );//加速度归零

        };

        this.checkBounds = function () {

            if ( this.position.x >   _width ) this.position.x = - _width;//如果从x轴右边出界，则返回x轴最左侧
            if ( this.position.x < - _width ) this.position.x =   _width;//如果x从轴左边出界，则返回x轴最右侧
            if ( this.position.y >   _height ) this.position.y = - _height;//如果从y轴一侧出界，则返回y轴另一侧
            if ( this.position.y < - _height ) this.position.y =  _height;//如果从y轴一侧出界，则返回y轴另一侧
            if ( this.position.z >  _depth ) this.position.z = - _depth;//如果从z轴一侧出界，则返回z轴另一侧
            if ( this.position.z < - _depth ) this.position.z =  _depth;//如果从z轴一侧出界，则返回z轴另一侧

        };

        //

        this.avoid = function ( target ) {

            var steer = new THREE.Vector3();

            steer.copy( this.position );
            steer.sub( target );//得到一个远离target的引导向量

            steer.multiplyScalar( 1 / this.position.distanceToSquared( target ) );//距离越大 这个引导向量越短 受力越小

            return steer;

        };
        //驱逐函数 相对target来驱逐
        this.repulse = function ( target ) {

            var distance = this.position.distanceTo( target );//与驱逐物的距离

            if ( distance < 150 ) {

                var steer = new THREE.Vector3();

                steer.subVectors( this.position, target );//一个远离target的引导向量
                steer.multiplyScalar( 0.5 / distance );//距离越大 向量越短 即对加速度影响越小

                _acceleration.add( steer );//影响加速度

            }

        };

        this.reach = function ( target, amount ) {

            var steer = new THREE.Vector3();

            steer.subVectors( target, this.position );//得到一个接近target的引导向量
            steer.multiplyScalar( amount );//乘以amount倍

            return steer;

        };
//        结盟
        this.alignment = function ( boids ) {

            var boid, velSum = new THREE.Vector3(),
                    count = 0;

            for ( var i = 0, il = boids.length; i < il; i++ ) {

                if ( Math.random() > 0.6 ) continue;

                boid = boids[ i ];

                distance = boid.position.distanceTo( this.position );

                if ( distance > 0 && distance <= _neighborhoodRadius ) {

                    velSum.add( boid.velocity );
                    count++;

                }

            }

            if ( count > 0 ) {

                velSum.divideScalar( count );

                var l = velSum.length();

                if ( l > _maxSteerForce ) {

                    velSum.divideScalar( l / _maxSteerForce );

                }

            }

            return velSum;//以百分之60的概率向所有的成员靠近

        };
//        凝聚力
        this.cohesion = function ( boids ) {

            var boid, distance,
                    posSum = new THREE.Vector3(),
                    steer = new THREE.Vector3(),
                    count = 0;

            for ( var i = 0, il = boids.length; i < il; i ++ ) {

                if ( Math.random() > 0.6 ) continue;

                boid = boids[ i ];
                distance = boid.position.distanceTo( this.position );

                if ( distance > 0 && distance <= _neighborhoodRadius ) {

                    posSum.add( boid.position );
                    count++;

                }

            }

            if ( count > 0 ) {

                posSum.divideScalar( count );

            }

            steer.subVectors( posSum, this.position );

            var l = steer.length();

            if ( l > _maxSteerForce ) {

                steer.divideScalar( l / _maxSteerForce );

            }

            return steer;

        };
//        分离
        this.separation = function ( boids ) {

            var boid, distance,
                    posSum = new THREE.Vector3(),
                    repulse = new THREE.Vector3();

            for ( var i = 0, il = boids.length; i < il; i ++ ) {

                if ( Math.random() > 0.6 ) continue;

                boid = boids[ i ];
                distance = boid.position.distanceTo( this.position );

                if ( distance > 0 && distance <= _neighborhoodRadius ) {

                    repulse.subVectors( this.position, boid.position );//得到一个远离的向量
                    repulse.normalize();//变成单位向量
                    repulse.multiplyScalar( 10 );
                    repulse.divideScalar( distance );//距离越小 分离的力量越大
                    posSum.add( repulse );

                }

            }

            return posSum;
        }
        //避开target点 范围n
        this.avoidPoint = function( target ,n)
        {
            if(target==null)return;

            vector.set( target.x+ n , this.position.y, this.position.z );//x轴左边的一个位置点 或者说从原点到这个点的向量
            vector = this.avoid( vector );//产生一个远离这个位置点的向量
            vector.multiplyScalar( 3 );//远离的向量的大小乘以5倍
            _acceleration.add( vector );//给加速度加上这个远离向量

            vector.set( target.x-n, this.position.y, this.position.z );
            vector = this.avoid( vector );
            vector.multiplyScalar( 3 );
            _acceleration.add( vector );

            vector.set( this.position.x, target.y+n, this.position.z );
            vector = this.avoid( vector );
            vector.multiplyScalar( 3 );
            _acceleration.add( vector );

            vector.set( this.position.x,target.y-n, this.position.z );
            vector = this.avoid( vector );
            vector.multiplyScalar( 3 );
            _acceleration.add( vector );

            vector.set( this.position.x, this.position.y, target.z+n );
            vector = this.avoid( vector );
            vector.multiplyScalar( 3 );
            _acceleration.add( vector );

            vector.set( this.position.x, this.position.y, target.z-n );
            vector = this.avoid( vector );
            vector.multiplyScalar( 3 );
            _acceleration.add( vector );
        }
        this.checkAvoidPointBounds = function (target,n) {
            if(target==null)return;
            vector=vector.sub(this.position,target.position);
            if((vector.x*vector.x+vector.y*vector.y+vector.z*vector.z)<3*n*n)//如果在不该靠近的范围内
            {
                this.position.x += n;
                this.position.y += n;
                this.position.z += n;
            }

        };

    }

</script>
<script>
    //        一些全局变量
    //绘制白琴键和黑琴键
    var blackKeyMode=0;//黑键模式 1为#升号 0为b降号
    var blackKeyModesChooseButton;//黑键模式选择按钮

    var blackKeyHeight=3;//黑琴键高度
    var blackKeyWidth=blackKeyHeight*1.5;//黑琴键宽度 等于高度的1.5倍
    var blackKeyDepth=blackKeyHeight*10;//黑琴键长度 等于高度的10倍
    var whiteKeyHeight=blackKeyHeight;//白琴键高度 等于黑键的高度
    var whiteKeyWidth=blackKeyHeight*2;//白琴键宽度 等于黑键的高度的2倍
    var whiteKeyDepth=blackKeyDepth*3/2;//白琴键长度 等于黑键的长度的二分之三倍
    var blackKey = new THREE.BoxGeometry(blackKeyWidth,blackKeyHeight,blackKeyDepth);//黑键形状
    var whiteKey = new THREE.BoxGeometry(whiteKeyWidth,whiteKeyHeight,whiteKeyDepth);//白键形状
    var blackKeyMesh=new THREE.MeshLambertMaterial({color:0x000000});//黑键材质
    var whiteKeyMesh = new THREE.MeshBasicMaterial({color:0xffffff});//白键材质
    var whiteKeyStartPosition=-156;//左边第一个白琴键的位置
    var blackKeyStartPosition=whiteKeyStartPosition+whiteKeyWidth/2;//左边第一个黑琴键的位置


    var px=whiteKeyStartPosition;//左边第一个白琴键x坐标
    var py=-30;//白琴键y坐标
    var pz=100;//白琴键z坐标
    var KeyKind;//鼠标点击时或移动时，保存最近一个被点击或指向的琴键的类型，便于在鼠标放开或移动时做相应处理
    var KeyNum;//鼠标点击时或移动时，保存最近一个被点击或指向的琴键的序号，便于在鼠标放开或移动时做相应处理
    var mousedown=0;//反映鼠标是否按下，0没按下，1已按下。

    //初始化键盘按键对应的琴键
    var keyFunction=[];

    var wKey;
    var objects=[];//可点击的物体们
    var whiteKeys=[];//白键们
    var blackKeys=[];//黑键们
    var whiteKeysEdges=[];//白键的边框们
    var edges=[];//边框们

    var blackKeyBoxs=[];//黑琴键按键提示盒子
    var whiteKeyBoxs=[];//白琴键按键提示盒子


    //自定义琴键的一些全局变量
    var keyboardSelfDefining=0;//是否正在自定义琴键 0否 1是
    var keyboardSelfDefineChoosed=0;//是否已经选中要定义的琴键 0否 1是
    var keyboardSelfDefineChoosedKey;//用户选中要进行自定义的琴键Object
    var keyboardRecoverButton;//琴键按键恢复初始化设置

    var keyboardkeyDown=[];

    var stats = new Stats();
    document.getElementById( 'container' ).appendChild(stats.dom);

    var birdButton;//关闭/开启飞鸟按钮
    var birdClosed=0;//是否关闭了飞鸟

    //        简谱基础教学选择
    var numberedMusicalNotationTeaching=1;
    var whiteKeyPlanes=[];
    var blackKeyPlanes=[];

    //    五线谱相关全局变量
    var blackKeyStavePositionY=[];//黑键在五线谱上的位置y
    var whiteKeyStavePositionY=[];//白键在五线谱上的位置y
    var staveCenterPositionY=40;//五线谱中心位置Y坐标
    var stavePositionZ=-30;//五线谱位置Z坐标
    var stavePlane;//五线谱板
    var stavePlaneLines=[];//五线谱线
    var staveNotePlanes=[];//五线谱音符
    var staveIng=1;
    var GclefPlane;
    var FclefPlane;
    var flats=[];
    var sharps=[];
    var blackKeyFlatAndSharpNum=[];

    //        初始化
    initAudio();
    initKey();
    var info = document.createElement( 'div' );
    info.style.position = 'absolute';
    info.style.top = '60px';
    info.style.fontWeight='bold'
    info.style.fontFamily='Arial'
    info.style.color = '#006633';
    info.style.width = '100%';
    info.style.textAlign = 'center';
    info.innerHTML = '点击琴键查看不同琴键对应音高音符';
    container.appendChild( info );

//    返回按钮
    var back = document.createElement( 'div' );
    back.style.position = 'absolute';
    back.style.right='20px';
    back.style.top = '20px';
    container.appendChild( back );
    var backImg = document.createElement("img");     //创建一个img元素  
    backImg.src="ButtonPictures/blackBack.png";   //给img元素的src属性赋值  
    backImg.width="50";
    backImg.height="50"
    back.appendChild(backImg);      //为dom添加子元素img 

    back.addEventListener( 'mousedown', clickBackButton, false );
    back.addEventListener( 'touchstart', clickBackButton, false );
    back.addEventListener('mousemove',highLightBackButton,false);
    function highLightBackButton() {
        backImg.src="ButtonPictures/redBackBold.png"
    }

    back.addEventListener('mouseout',blackenBackButton,false);
    function blackenBackButton() {
        backImg.src="ButtonPictures/blackBack.png"
    }

    //        创建场景
    var scene=new THREE.Scene();
    //        给场景设置背景
//    scene.background = new THREE.CubeTextureLoader()
//            .setPath( 'MilkyWay/' )
//            .load( [ 'dark-s_px.jpg', 'dark-s_nx.jpg', 'dark-s_py.jpg', 'dark-s_ny.jpg', 'dark-s_pz.jpg', 'dark-s_nz.jpg' ] );

    //        创建灯光
    var ambientLight=new THREE.AmbientLight(0xffffff);
    scene.add(ambientLight);
    var pointlight=new THREE.PointLight(0xf0f0f0);
    pointlight.position.set(500,500,500);
    scene.add(pointlight);
    //        创建照相机
    var camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,5000);
    camera.position.set(0,101,262);
    camera.lookAt(scene.position);
    //        创建渲染器
    var renderer= new THREE.WebGLRenderer();
    renderer.setClearColor(0xf0f0f0);
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement);
    //        渲染函数
    function render() {
        renderer.render(scene,camera);
    }
    //        创建控制器
//    var control=new THREE.OrbitControls(camera);
//    control.addEventListener('change',render);
    //        动画控制函数
    function animate() {

        stats.begin();
        requestAnimationFrame(animate);
        render();
        stats.end();
    }
    animate();
    //        监听窗口大小改变
    window.addEventListener('resize',onWindowResize,false);
    function onWindowResize() {
        camera.aspect=window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth,window.innerHeight);
        render();
    }

    //        绘制白琴键
    var whiteKeyNum=201;

    while(whiteKeyNum<=252){
        wKey=new THREE.Mesh(
                new THREE.myBoxGeometry(whiteKeyWidth,whiteKeyHeight,whiteKeyDepth),
                new THREE.MeshBasicMaterial({color:0xffffff}));//新建一个白键
        /*注意：
         不要写
         var wKey=new THREE.Mesh(whiteKey,whiteKeyMaterial);
         会导致点下一个白键的效果，等于所有白键都被点击
         */
        var edges = new THREE.EdgesHelper( wKey, 0xa0a0a0 );//给白键加一个边框
        scene.add(wKey);//将白键追加到场景中
        scene.add(edges);//将白键的边框加到场景中
        whiteKeysEdges.push(edges);//将白键的边框加到白键边框数组中
        objects.push(wKey);//将白键加到可被点击的物体数组中
        whiteKeys.push(wKey);//加入白键数组中
        wKey.num=whiteKeyNum; //设置琴键序号
        wKey.kind='whiteKey';//设置琴键类型为白键
        whiteKeyNum+=1; //下一个白键的序号
        wKey.position.x=px;//白键x坐标
        wKey.position.y=py;//白键y坐标
        wKey.position.z=pz;//白键z坐标
        px+=whiteKeyWidth+0.1; //下一个白键横坐标位置 0.1的琴键间隙
    }

    // //绘制黑琴键
    var px2=blackKeyStartPosition;
    var py2=py+2;
    var pz2=pz-5;
    var blackKeyNum=101;

    wKey=new THREE.Mesh(new THREE.BoxGeometry(
            blackKeyWidth,blackKeyHeight,blackKeyDepth),
            new THREE.MeshLambertMaterial({color:0x000000}));
    scene.add(wKey);
    objects.push(wKey);//将黑键加到可被点击的物体数组中
    blackKeys.push(wKey);//加入黑键数组中
    wKey.num=blackKeyNum;
    wKey.kind='blackKey';//设置琴键类型为黑键
    blackKeyNum+=1;
    wKey.position.x=px2;
    wKey.position.y=py2;
    wKey.position.z=pz2;
    px2+=whiteKeyWidth+0.1;
    px2+=whiteKeyWidth+0.1;

    for (var i = 7-1; i >= 0; i--) {
        for (var j = 1; j<=5; j++) {
            wKey=new THREE.Mesh(new THREE.BoxGeometry(
                    blackKeyWidth,blackKeyHeight,blackKeyDepth),
                    new THREE.MeshLambertMaterial({color:0x000000}));
            scene.add(wKey);
            wKey.num=blackKeyNum;
            blackKeyNum+=1;
            wKey.kind='blackKey';//设置琴键类型为黑键
            objects.push(wKey);//将黑键加到可被点击的物体数组中
            blackKeys.push(wKey);//加入黑键数组中
            wKey.position.x=px2;
            wKey.position.y=py2;
            wKey.position.z=pz2;
            px2+=whiteKeyWidth+0.1;
            if(j==2||j==5){
                px2+=whiteKeyWidth+0.1;
            }
        };
    }
    //        监听事件

    var raycaster=new THREE.Raycaster();
    var mouse=new THREE.Vector2();
    document.addEventListener('mousedown',onMouseDown,false);//监听鼠标按下事件
    document.addEventListener('mouseup',onMouseUp,false);//监听鼠标抬起事件
    document.addEventListener('mousemove',onMouseMove,false);//监听鼠标移动事件

    //        监听鼠标按下事件函数
    function onMouseDown (event) {
        event.preventDefault();
        if(keyboardSelfDefining==1)//如果正在进行鼠标自定义
        {
            keyboardSelfDefindingOnMouseDown(event);
        }
        else//自由弹奏
        {
            playPianoOnMouseDown(event);
        }

    }
    //        监听鼠标抬起事件函数
    function onMouseUp (event) {
        event.preventDefault();
        mousedown=0;//反映鼠标没有按下
        var knum;
        if(keyboardSelfDefining==1)//如果正在自定义按键
        {
            ;//不做任何处理
        }
        else if(KeyNum)
        {

            if(staveIng==1)//如果五线谱教学模式开启
            {
                staveKeyUp(KeyNum);
            }
            if(KeyKind=='whiteKey')
            {
                knum=KeyNum-201;//根据琴键序号KeyNum查找白键序号
                whiteKeys[knum].material.color.setHex(0xffffff);//恢复白键原来的颜色
                if(numberedMusicalNotationTeaching==1)//如果教学模式开启
                {
                    fade(whiteKeyPlanes[knum],10);}

            }
            else if(KeyKind=='blackKey')
            {
                knum=KeyNum-101;//根据琴键序号KeyNum查找黑键序号
                blackKeys[knum].material.color.setHex(0x000000);//恢复黑键原来的颜色
                if(numberedMusicalNotationTeaching==1)//如果教学模式开启
                {
                    fade(blackKeyPlanes[knum],10);
                }
            }
            else
            {
            }

        }
        else if(KeyKind=='waterfallButton')
        {
            waterfallButton.material.color.setHex(0xffffff);
        }
        else
        {
        }
        render();
        mouseup=1;
    }

    //        监听鼠标移动事件函数
    function onMouseMove (event) {

        event.preventDefault();

        if(keyboardSelfDefining==1)//正在自定义琴键
        {
            ;//不作任何处理
        }
        else if(mousedown==1)
        {
//            var pKeyNum;
//            var pKeyKind;
            //将屏幕像素坐标转化成camare坐标
            mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

            raycaster.setFromCamera(mouse,camera);//mouse是鼠标的二维坐标，camera是射线起点处的相机，即把射线起点设置在camera的位置
            var intersects=raycaster.intersectObjects(objects);//objects是要被判断是否被射线穿过的物体们，objects是个数组，下标越小离射线起点越近
            if(intersects.length>0)
            {
                //是琴键 并且是有滑动到了另一个琴键上
                if(intersects[0].object.num && (intersects[0].object.num!=KeyNum)&&intersects[0].object.kind=='whiteKey'||intersects[0].object.kind=='blackKey')
                {
                    //处理前一个琴键。恢复颜色
                    if(mouseup==0)//如果mouseup==1 则无需处理
                    {
                        if(KeyKind=='whiteKey')
                        {
                            knum=KeyNum-201;
                            whiteKeys[knum].material.color.setHex(0xffffff);
                            if(numberedMusicalNotationTeaching==1)//如果教学模式开启
                            {
                                fade(whiteKeyPlanes[knum],10);}
                        }
                        else if(KeyKind=='blackKey')
                        {
                            knum=KeyNum-101;
                            blackKeys[knum].material.color.setHex(0x000000);
                            if(numberedMusicalNotationTeaching==1)//如果教学模式开启
                            {
                                fade(blackKeyPlanes[knum],10);
                            }
                        }
                        else
                        {
                            ;
                        }
                        if(staveIng==1)//如果五线谱教学模式开启
                        {
                            staveKeyUp(KeyNum)
                        }
                    }

                    //处理现在的琴键，播放声音，改变颜色
                    if(intersects[0].object.kind=='whiteKey'||intersects[0].object.kind=='blackKey')
                    {
                        intersects[0].object.material.color.setHex(0xa0a0a0);
                        if(intersects[0].object.num)
                        {
                            playAudio(intersects[0].object.num);//播放对应序号琴键的声音
                            if(numberedMusicalNotationTeaching==1)//如果简谱教学模式开启
                            {
                                showPlane(intersects[0].object.num)
                            }

                            if(staveIng==1)//如果五线谱教学模式开启
                            {
                                staveKeyDown(intersects[0].object.num)
                            }
                        }
                        render();
                    }
//                        }
                    else
                    {
                        ;
                    }
                    KeyKind=intersects[0].object.kind;//记录当前点击的类型
                    KeyNum=intersects[0].object.num;//记录当前序号
                }
                else//不是琴键
                {
                    ;
                }

            }
        }
    }
    //        音频初始化
    function initAudio()
    {
        for(var i=101;i<=136;i++)
        {
            var audio=document.createElement("audio");
            audio.id='myaudio'+i;
            document.body.appendChild(audio);
            var qianzhui='pianoKey/';
            var houzhui='.mp3';
            var source=qianzhui+i+houzhui;
            audio.src=source;
        }
        for(var i=201;i<=252;i++)
        {
            var audio=document.createElement("audio");
            audio.id='myaudio'+i;
            document.body.appendChild(audio);
            var qianzhui='pianoKey/';
            var houzhui='.mp3';
            var source=qianzhui+i+houzhui;
            audio.src=source;
        }
    }
    //        播放音频函数
    function playAudio ( name) {
        aname='myaudio'+name;
        var myaudio=document.getElementById(aname);
        myaudio.stop();//如果原先已经在播放中，先结束播放
        myaudio.play();
    }
    //        瀑布流之播放音频函数
    function waterfallPlayAudio ( name)
    {
        var name1=name+200;
        aname='myaudio'+name1;
        var myaudio=document.getElementById(aname);
        myaudio.stop();//如果原先已经在播放中，先结束播放
        myaudio.play();
    }
    //        结束音频播放函数
    HTMLAudioElement.prototype.stop = function()
    {
        this.pause();
        this.currentTime = 0.0;
    }
    //        停止播放音频函数
    function stopAudio ( name) {
        aname='myaudio'+name;
        if(name<10)
            name='0'+name;
        var myaudio=document.getElementById(aname);
        myaudio.stop();
    }

    //        给琴键添加键盘按键对应效果

    document.addEventListener('keydown',onKeyDown,false);
    document.addEventListener('keyup',onKeyUp,false);
    //        键盘按键与琴键的对应关系初始化
    function initKey () {
        var i;
        for(i=0;i<300;i++)
        {
            keyFunction[i]=0;
        }
        // keyFunction[键值]=对应音频（琴键）序号;
        // 第一行按键
        keyFunction[49]=233;// ! 和 1 按键
        keyFunction[50]=234;// @ 和 2 按键
        keyFunction[51]=124;// # 和 3 按键
        keyFunction[52]=235;// $ 和 4 按键
        keyFunction[53]=125;// % 和 5 按键
        keyFunction[54]=236;// ^ 和 6 按键
        keyFunction[55]=126;// & 和 7 按键
        keyFunction[56]=237;// * 和 8 按键
        keyFunction[57]=238;// ( 和 9 按键
        keyFunction[48]=127;// ) 和 0 按键
        keyFunction[189]=239;// _ 和 - 按键
        keyFunction[187]=128;// + 和 = 按键
        keyFunction[8]=240;// backspace 按键

        //第二行按键
        keyFunction[81]=114;//Q
        keyFunction[87]=115;//W
        keyFunction[69]=116;//E
        keyFunction[82]=224;//R
        keyFunction[84]=117;//T
        keyFunction[89]=118;//Y
        keyFunction[85]=226;//U
        keyFunction[73]=119;//I
        keyFunction[79]=120;//O
        keyFunction[80]=121;//P
        keyFunction[219]=231;// { 和 [ 按键
        keyFunction[221]=122;// } 和 ] 按键
        keyFunction[220]=123;// | 和 \ 按键

        //第三行按键
        keyFunction[65]=221;//A
        keyFunction[83]=222;//S
        keyFunction[68]=223;//D
        keyFunction[70]=224;//F
        keyFunction[71]=225;//G
        keyFunction[72]=226;//H
        keyFunction[74]=227;//J
        keyFunction[75]=228;//K
        keyFunction[76]=229;//L
        keyFunction[186]=230;//分号按键
        keyFunction[222]=231;//单引号按键
        keyFunction[13]=232;//回车键

        //第四行按键
        keyFunction[90]=110;//Z
        keyFunction[88]=215;//X
        keyFunction[67]=111;//C
        keyFunction[86]=216;//V
        keyFunction[66]=217;//B
        keyFunction[78]=112;//N
        keyFunction[77]=218;//M
        keyFunction[188]=113;// < 和 , 按键
        keyFunction[190]=219;// > 和 . 按键
        keyFunction[191]=220;// ? 和 / 按键
    }
    //        监听键盘按键的处理函数
    function onKeyDown (event) {
        // event.preventDefault();


        var i=0;
        var num;
        kbnum=event.keyCode;
        if(kbnum==17){
            return;
        }
        if(keyboardkeyDown[kbnum]==1)
        {
            ;
        }
//            alert(kbnum);
        else if(keyboardSelfDefining==1)//正在自定义琴键
        {
            if(keyboardSelfDefineChoosed==1)//已经选中要定义的琴键
            {
                if(keyFunction[keyFunction[kbnum]==0])//如果没有定义过该按键
                {
                    console.log('can not self-define this keyboard key, please choose an other one');//
                }
                else
                {
                    ;//修改键盘按键提示图片
                    if(keyFunction[kbnum]!=-1&&keyFunction[kbnum]!=0)//如果该按键原来对应的琴键没有被置空 且按键是合法按键
                    {
                        if(keyFunction[kbnum]>200&&keyFunction[kbnum]<=252)//判断是按键原来对应的是白键
                        {
                            whiteKeyBoxs[keyFunction[kbnum]-201].material.map=THREE.ImageUtils.loadTexture('KeyboardPictures/null.png');// 按键原来对应的提示盒子设置空白图片
//                            whiteKeyBoxs[keyFunction[kbnum]-201].material.color.setHex(0x99efef);
                        }
                        else if(keyFunction[kbnum]>100&&keyFunction[kbnum]<=136)
                        {
                            blackKeyBoxs[keyFunction[kbnum]-101].material.map=THREE.ImageUtils.loadTexture('KeyboardPictures/null.png');// 按键原来对应的提示盒子设置空白图片
                        }
                        console.log('set '+keyFunction[kbnum]+'KeyboardPicture null')
                    }

                    ;// 按键原来对应的提示盒子设置空
//                        现在按下的琴键的原来对应的按键设置空
                    for(i=0;i<300;i++)
                    {
                        if(keyFunction[i]==keyboardSelfDefineChoosedKey.num)
                        {
                            keyFunction[i]=-1;
                        }
                    }
                    ;//按键现在对应的提示盒子设置图片

                    keyFunction[kbnum]=keyboardSelfDefineChoosedKey.num;//修改键盘按键对应音频
                    var pictureSrc='KeyboardPictures/'+kbnum+'.png';
                    if(keyFunction[kbnum]>200&&keyFunction[kbnum]<=252)//判断是按键现在对应的是白键
                    {
                        whiteKeyBoxs[keyFunction[kbnum]-201].material.map=THREE.ImageUtils.loadTexture(pictureSrc);// 按键现在对应的提示盒子设置图片
                        console.log('set whiteKeyBoxs '+keyFunction[kbnum]+''+pictureSrc);
                    }
                    else if(keyFunction[kbnum]>100&&keyFunction[kbnum]<=136)
                    {
                        blackKeyBoxs[keyFunction[kbnum]-101].material.map=THREE.ImageUtils.loadTexture(pictureSrc);// 按键现在对应的提示盒子设置图片
                        console.log('set blackKeyBoxs '+keyFunction[kbnum]+''+pictureSrc);
                    }
                }

            }

            if(numberedMusicalNotationTeaching==1)//如果简谱教学模式开启
            {
                showPlane(intersects[0].object.num)
            }
        }
        else
        {
            keynum=keyFunction[kbnum];//琴键序号
            if(keynum!=0&&keynum!=-1)//有对应的琴键
            {
                playAudio(keynum);
                if(numberedMusicalNotationTeaching==1)//如果简谱教学模式开启
                {
                    showPlane(keynum)
                }
                if(staveIng==1)//如果五线谱教学模式开启
                {
                    staveKeyDown(keynum);
                }
                if(keynum>200&&keynum<253)//白键
                {
                    KeyBoardKeyKind='whiteKey';
                    num=keynum-201;
                    whiteKeys[num].material.color.setHex(0xa0a0a0);
                }
                else if(keynum>100&&keynum<137)//黑键
                {
                    //     alert(kind+'blackKey');
                    KeyBoardKeyKind='blackKey';
                    num=keynum-101;
                    blackKeys[num].material.color.setHex(0xa0a0a0);
                }
                render();

            }
            else
            {
                // alert(i);
            }

        }
        keyboardkeyDown[kbnum]=1;

    }
    //        监听键盘按键抬起的处理函数
    function onKeyUp (event) {
        var i=0;
        var num;
        kbnum=event.keyCode;
        keyboardkeyDown[kbnum]=0;//标志抬起
        keynum=keyFunction[kbnum];//琴键序号
        if(keynum!=0)
        {
            if(keynum>200&&keynum<253)
            {
                KeyBoardKeyKind='whiteKey';
                num=keynum-201;
                whiteKeys[num].material.color.setHex(0xffffff);

                if(numberedMusicalNotationTeaching==1)//如果简谱教学模式开启
                {
                    fade(whiteKeyPlanes[num],10)
                }
                if(staveIng==1)//如果五线谱教学模式开启
                {
                    staveKeyUp(keynum)
                }
            }
            else if(keynum>100&&keynum<137)
            {
                KeyBoardKeyKind='blackKey';
                num=keynum-101;
                blackKeys[num].material.color.setHex(0x000000);
                if(numberedMusicalNotationTeaching==1)//如果简谱教学模式开启
                {
                    fade(blackKeyPlanes[num],10)
                }
                if(staveIng==1)//如果五线谱教学模式开启
                {
                    staveKeyUp(keynum)
                }
            }
            render();
        }
        else
        {
            ;
        }
    }
    //        添加键盘按键提示方块
    //添加白色琴键对应键盘按键提示方块
    var whiteKeyPictureNum=201;//白色琴键对应键盘提示方块的编号
    var wKeyBox;//白色琴键对应键盘提示方块
    var px3=whiteKeyStartPosition;//左边第一个白色琴键对应键盘按键提示方块的x坐标
    var py3=py+1;//白色琴键对应键盘提示方块的y坐标
    var pz3=pz+25;//白色琴键对应键盘提示方块的z坐标

    for(whiteKeyPictureNum=201;whiteKeyPictureNum<=252;whiteKeyPictureNum++){
        wKeyBox=new THREE.Mesh(
                new THREE.BoxGeometry(whiteKeyWidth,whiteKeyWidth,whiteKeyWidth),
                new THREE.MeshLambertMaterial({color:0x99efef,map:THREE.ImageUtils.loadTexture('KeyboardPictures/null.png')}));//新建一个白键按键提示盒子
        wKeyBox.material.transparent=true;
        scene.add(wKeyBox);//将白键按键提示盒子追加到场景中
        objects.push(wKeyBox);//将白键按键提示盒子加到可被点击的物体数组中
        whiteKeyBoxs.push(wKeyBox);//加入白键按键提示盒子数组中
        wKeyBox.num=whiteKeyPictureNum; //设置白键按键提示盒子序号
        wKeyBox.kind='whiteKeyBox';//设置琴键类型为白键按键提示盒子
        wKeyBox.position.x=px3;//白键按键提示盒子x坐标
        wKeyBox.position.y=py3;//白键按键提示盒子y坐标
        wKeyBox.position.z=pz3;//白键按键提示盒子z坐标
        px3+=whiteKeyWidth+0.1; //下一个白键横坐标位置 0.1的琴键间隙
    }
    //绘制黑琴键按键提示盒子
    var px4=blackKeyStartPosition;//左边第一个黑色琴键按键提示盒子的x坐标
    var py4=py+blackKeyWidth-0.5;
    var pz4=pz-22;
    var blackKeyBoxNum=101;
    var bKeyBox;

    var geometry=new THREE.BoxGeometry(
            blackKeyWidth,blackKeyWidth,blackKeyWidth)
    geometry.rotateX(Math.PI/3);
    bKeyBox=new THREE.Mesh(geometry,
            new THREE.MeshBasicMaterial({color:0xffffff,map:THREE.ImageUtils.loadTexture('KeyboardPictures/null.png')}));
    scene.add(bKeyBox);
    objects.push(bKeyBox);//将黑键按键提示盒子加到可被点击的物体数组中
    blackKeyBoxs.push(bKeyBox);//加入黑键按键提示盒子数组中
    bKeyBox.num=blackKeyBoxNum;
    bKeyBox.kind='blackKeyBox';//设置琴键类型为黑键提示盒子
    bKeyBox.material.transparent=true;
    blackKeyBoxNum+=1;
    bKeyBox.position.x=px4;
    bKeyBox.position.y=py4;
    bKeyBox.position.z=pz4;
    px4+=whiteKeyWidth+0.1;
    px4+=whiteKeyWidth+0.1;

    for (var i = 7-1; i >= 0; i--)
    {
        for (var j = 1; j<=5; j++) {
            var geometry=new THREE.BoxGeometry(
                    blackKeyWidth,blackKeyWidth,blackKeyWidth)
            geometry.rotateX(Math.PI/3);
            bKeyBox=new THREE.Mesh(geometry,
                    new THREE.MeshLambertMaterial({color:0x99efef,map:THREE.ImageUtils.loadTexture('KeyboardPictures/null.png')}));
            scene.add(bKeyBox);
            bKeyBox.num=blackKeyBoxNum;
            blackKeyBoxNum+=1;
            bKeyBox.kind='blackKeyBox';//设置琴键类型为黑键
            objects.push(bKeyBox);//将黑键加到可被点击的物体数组中
            blackKeyBoxs.push(bKeyBox);//加入黑键数组中
            bKeyBox.material.transparent=true;
            bKeyBox.position.x=px4;
            bKeyBox.position.y=py4;
            bKeyBox.position.z=pz4;
            px4+=whiteKeyWidth+0.1;
            if(j==2||j==5){
                px4+=whiteKeyWidth+0.1;
            }
        };
    }
     //初始化白色琴键按键提示盒子的图片
    function updateBoxsPicture() //键盘按键提示盒子图片更新
    {
        var boxImgName;//图片名字
        var num;
        for(var i=0;i<250;i++)
        {
            if(keyFunction[i]!=0)
            {
                if(keyFunction[i]>=201&&keyFunction[i]<253)
                {
                    boxImgName='KeyboardPictures/'+i+'.png';
                    num=keyFunction[i]-201;
                    whiteKeyBoxs[num].material.map=THREE.ImageUtils.loadTexture(boxImgName);
                }
                else if(keyFunction[i]>100&&keyFunction[i]<137)
                {
                    boxImgName='KeyboardPictures/'+i+'.png';
                    num=keyFunction[i]-101;
                    blackKeyBoxs[num].material.map=THREE.ImageUtils.loadTexture(boxImgName);
                }
            }
        }
    }
    updateBoxsPicture();

    //         添加键盘自定义按钮
    var keyboardSelfDefineCube=new THREE.Mesh(
            new THREE.myBoxGeometry(20,20,20)
            ,new THREE.MeshLambertMaterial({color:0xffffff,map:THREE.ImageUtils.loadTexture('ButtonPictures/keyboardSelfDefine.png')})
    )
    keyboardSelfDefineCube.position.set(-15,40,pz-54);
    keyboardSelfDefineCube.kind='keyboardSelfDefineCube';
    function clickKeyboardSelfDefineButton()
    {
        if(keyboardSelfDefining==1)//如果正在进行键盘按键琴键自定义
        {
            keyboardSelfDefining=0;
            keyboardSelfDefineCube.material.map=THREE.ImageUtils.loadTexture('ButtonPictures/keyboardSelfDefine.png');

            if(keyboardSelfDefineChoosed==1)
            {
                keyboardSelfDefineKeyUp(keyboardSelfDefineChoosedKey);
            }
            console.log('1')
        }
        else
        {
            keyboardSelfDefining=1;
            keyboardSelfDefineCube.material.map=THREE.ImageUtils.loadTexture('ButtonPictures/endKeyboardSelfDefine.png');

            if(keyboardSelfDefineChoosed==1)
            {
                keyboardSelfDefineKeyUp(keyboardSelfDefineChoosedKey);
            }
            console.log('2')
        }
    }
    //        自定义键盘按键时，琴键按下
    function keyboardSelfDefineKeyDown(key)
    {
        if(keyboardSelfDefineChoosed==1)
        {
            keyboardSelfDefineKeyUp(keyboardSelfDefineChoosedKey);
        }
        if(key.num>200&&key.num<=252)//白键
        {
            whiteKeys[key.num-201].material.color.setHex(0x8f0000);
            playAudio(key.num);
            keyboardSelfDefineChoosedKey=key;
        }
        else if(key.num>100&&key.num<=136)//黑键
        {
            blackKeys[key.num-101].material.color.setHex(0x8f0000);
            playAudio(key.num);
            keyboardSelfDefineChoosedKey=key;
        }
        keyboardSelfDefineChoosed=1;
    }
    //        自定义键盘按键时，琴键抬起
    function keyboardSelfDefineKeyUp(key)
    {
        if(key.num>200&&key.num<=252)//白键
        {
            whiteKeys[key.num-201].material.color.setHex(0xffffff);
        }
        else if(key.num>100&&key.num<=136)//黑键
        {
            blackKeys[key.num-101].material.color.setHex(0x000000);
        }
        ;
    }
    //        自由弹奏时，监听鼠标按下事件
    function playPianoOnMouseDown(event)
    {
        mouseup=0;
        //将屏幕像素坐标转化成camare坐标
        mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
        mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

        raycaster.setFromCamera(mouse,camera);//mouse是鼠标的二维坐标，camera是射线起点处的相机，即把射线起点设置在camera的位置
        var intersects=raycaster.intersectObjects(objects);//objects是要被判断是否被射线穿过的物体们，objects是个数组，下标越小离射线起点越近

        if(intersects.length>0)//点击到了物体
        {
            if(intersects[0].object.kind=='whiteKey'||intersects[0].object.kind=='blackKey')//判断是否钢琴键
            {
                KeyKind=intersects[0].object.kind;//记录当前点击的琴键类型
                intersects[0].object.material.color.setHex(0xa0a0a0);//改变颜色
                if(intersects[0].object.num)//检查是否拥有num属性
                {
                    KeyNum=intersects[0].object.num;//记录当前琴键序号
                    playAudio(intersects[0].object.num);//播放对应音频
                    console.log('自由弹奏琴键序号：'+intersects[0].object.num)
                    if(numberedMusicalNotationTeaching==1)//如果简谱教学模式开启
                    {
                        showPlane(intersects[0].object.num)
                    }
                    if(staveIng==1)//如果五线谱教学模式开启
                    {
                        staveKeyDown(intersects[0].object.num)
                    }
                }

            }
            else if(intersects[0].object.kind=='whiteKeyBox'||intersects[0].object.kind=='blackKeyBox')//点击到按键提示盒子
            {
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }
            else if(intersects[0].object.kind=='keyboardSelfDefineCube')//点击到了键盘自定义方块按钮
            {
                clickKeyboardSelfDefineButton();
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }
            else if(intersects[0].object.name=='blackKeyModesChooseButton')//点击到了黑键模式选择按钮
            {
                clickBlackKeyModesChooseButton();
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }
            else
            {
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }

        }
        else//没有点击到可点击的物体
        {
        }
        render();//渲染
        mousedown=1;//反映鼠标已经按下
    }
    //        初始化键盘按键是否按下的标志数组
    function initKeyboardKeyDown()
    {
        var i=0;
        for(i=0;i<300;i++)
        {
            keyboardkeyDown[i]=0;
        }
    }
    initKeyboardKeyDown();

    function clickBackButton()
    {
        window.open('index.html','_self')
    }
    //        黑键模式选择按钮
    geometry=new THREE.BoxGeometry(20,20,20)
    geometry.rotateY(Math.PI/3);
    geometry.rotateX(-Math.PI/12);
    blackKeyModesChooseButton=new THREE.Mesh(geometry,
            new THREE.MeshLambertMaterial({color:0xffffff}));
    blackKeyModesChooseButton.position.set(200,25,-54);
    blackKeyModesChooseButton.name='blackKeyModesChooseButton';
    updateBlackKeyModesChooseButtonPicture();
    scene.add(blackKeyModesChooseButton);
    objects.push(blackKeyModesChooseButton);
    //        黑键模式选择按钮图片更新
    function updateBlackKeyModesChooseButtonPicture()
    {
        if(blackKeyMode==0)
        {
            blackKeyModesChooseButton.material.map=THREE.ImageUtils.loadTexture('ButtonPictures/blackKeyModeDown.png');
        }
        else if(blackKeyMode==1){
            blackKeyModesChooseButton.material.map=THREE.ImageUtils.loadTexture('ButtonPictures/blackKeyModeUp.png');
        }

    }
    //        黑键模式选择按钮被点击的处理函数
    function clickBlackKeyModesChooseButton()
    {
        blackKeyMode++;
        blackKeyMode=Math.floor(blackKeyMode%2);
        updateBlackKeyModesChooseButtonPicture();
        updateBlackKeyPlanesPicture();
    }
    //        更新提示盒子的图片为音高
    function updateKeyBoxesOnPitch()
    {
        var i=0,j;
        if(blackKeyMode==0)
        {
            for(i = 0;i<blackKeyBoxs.length;i++)
            {
                j=101+i;
                blackKeyBoxs[i].material.map=THREE.ImageUtils.loadTexture('waterfallPitchPictures/down'+j+'.png')
            }
        }
        else
        {
            for(i = 0;i<blackKeyBoxs.length;i++)
            {
                j=101+i;
                blackKeyBoxs[i].material.map=THREE.ImageUtils.loadTexture('waterfallPitchPictures/up'+j+'.png')
            }
        }
        for(i = 0;i<whiteKeyBoxs.length;i++)
        {
            j=201+i;
            whiteKeyBoxs[i].material.map=THREE.ImageUtils.loadTexture('waterfallPitchPictures/'+j+'.png')
        }
    }
    //        初始化简谱音高图片
    function initKeyPlanes()
    {
        var i,KeyPlane,p,j ,k;
        p=blackKeyStartPosition;
        j=1;
        for(i=101;i<=136;i++)
        {
            KeyPlane=new THREE.Mesh(new THREE.PlaneGeometry(20,20),new THREE.MeshLambertMaterial({color:0xffffff}))
            KeyPlane.name='blackKeyPlane'+i;
            KeyPlane.position.x=p;
            KeyPlane.position.y=30;
            KeyPlane.position.z=-29;
            KeyPlane.material.transparent=true;
            KeyPlane.material.alpha=0;
            KeyPlane.visible=false;
            scene.add(KeyPlane);
            blackKeyPlanes.push(KeyPlane);
            k=j%5;
            if(k==1||k==4)
            {
                p=p+whiteKeyWidth+0.1;
            }
            j++;
            p=p+whiteKeyWidth+0.1;
        }
        updateBlackKeyPlanesPicture();
        for(i=201;i<=252;i++)
        {
            KeyPlane=new THREE.Mesh(new THREE.PlaneGeometry(20,20),new THREE.MeshLambertMaterial({color:0xffffff,map:THREE.ImageUtils.loadTexture('waterfallPitchPictures/'+i+'.png')}))
            KeyPlane.name='whitekKeyPlane'+i;
            KeyPlane.position.x=whiteKeyStartPosition+(i-201)*(whiteKeyWidth+0.1)
            KeyPlane.position.y=20
            KeyPlane.position.z=-29;
            KeyPlane.material.transparent=true;
            KeyPlane.visible=false;
            KeyPlane.material.alpha=0;
            scene.add(KeyPlane);
            whiteKeyPlanes.push(KeyPlane);
        }
    }
    initKeyPlanes();
    //        更新简谱音高图片
    function updateBlackKeyPlanesPicture()
    {
        var i;
        if(blackKeyMode==0)
        {
            for(i=101;i<=136;i++)
            {
                blackKeyPlanes[i-101].material.map=THREE.ImageUtils.loadTexture('waterfallPitchPictures/down'+i+'.png')
            }
        }
        else
        {
            for(i=101;i<=136;i++)
            {
                blackKeyPlanes[i-101].material.map=THREE.ImageUtils.loadTexture('waterfallPitchPictures/up'+i+'.png')
            }
        }
    }
    function fade(mesh,n)
    {
        mesh.alpha=0;

        mesh.visible=false;
    }
    function showPlane(planeNum)
    {
        i=planeNum

        if(i>200&&i<=252)
        {
            whiteKeyPlanes[i-201].visible=true;
        }
        else if(i>100&&i<=136)
        {
            blackKeyPlanes[i-101].visible=true;
        }
    }

    initStave();
    //      初始化五线谱
    function initStave()
    {
        initStavePosition();
        var staveLine;
//            五线谱背景板
        stavePlane=new THREE.Mesh(new THREE.PlaneGeometry(320,56),
                new THREE.MeshLambertMaterial({color:0xffffff}));
        stavePlane.position.y=staveCenterPositionY;
        stavePlane.position.z=stavePositionZ;
        stavePlane.visible=false;
        stavePlane.name='stavePlane';
        scene.add(stavePlane);
        j=0;
        for(i=11;i>0;i--)//五线谱上的线
        {
            if(i==6)
            {
                staveLine=new THREE.Mesh(new THREE.BoxGeometry(whiteKeyWidth,1,1),
                        new THREE.MeshLambertMaterial({color:0x0099ff}));
                staveLine.position.x=whiteKeys[23].position.x;
            }
            else {
                staveLine=new THREE.Mesh(new THREE.BoxGeometry(320,1,1),
                        new THREE.MeshLambertMaterial({color:0x0099ff}));
            }
            staveLine.position.y=staveCenterPositionY-20+4*i;
            staveLine.position.z=stavePositionZ+0.5;
            staveLine.visible=false;
            staveLine.name='staveLine'+j;
            stavePlaneLines.push(staveLine);
            scene.add(staveLine);
            j++;
        }
        //高音谱号
        GclefPlane=new THREE.Mesh(new THREE.PlaneGeometry(14.7,29),
                new THREE.MeshLambertMaterial({color:0xffffff,map:THREE.ImageUtils.loadTexture('stavePictures/Gclef.png')}));
        GclefPlane.visible=false;
        GclefPlane.material.transparent=true;
        GclefPlane.name='GclefPlane';
        GclefPlane.position.x=whiteKeyStartPosition+5;
        GclefPlane.position.y=staveCenterPositionY+16;
        GclefPlane.position.z=stavePositionZ+0.1;

        scene.add(GclefPlane);
        FclefPlane=new THREE.Mesh(new THREE.PlaneGeometry(14,14),
                new THREE.MeshLambertMaterial({color:0xffffff,map:THREE.ImageUtils.loadTexture('stavePictures/Fclef.png')}));
        FclefPlane.visible=false;
        FclefPlane.material.transparent=true;
        FclefPlane.name='FclefPlane';
        FclefPlane.position.x=whiteKeyStartPosition+5;
        FclefPlane.position.y=staveCenterPositionY-6;
        FclefPlane.position.z=stavePositionZ+0.1;
        scene.add(FclefPlane);
        initStaveNotes();
    }
    //    初始化五线谱位置数组
    function initStavePosition()
    {
        var i,j,k,p;
        for(i=1;i<=52;i++)
        {
            p=staveCenterPositionY+(i-22)*2;
            whiteKeyStavePositionY.push(p);
        }
        j=0;
        for(i=1;i<=36;i++)
        {
            k=i%5;
            blackKeyStavePositionY.push(whiteKeyStavePositionY[j]);
            if(k==1||k==4)j++;
            j++;
        }
    }
    //      初始化五线谱上的音符
    function initStaveNotes()
    {
        var notePlane;
        for(i=0;i<52;i++)
        {
            notePlane=new THREE.Mesh(new THREE.PlaneGeometry(4.9,4),
                    new THREE.MeshBasicMaterial({color:0xffffff,map:THREE.ImageUtils.loadTexture('stavePictures/SemibreveGray.png')}));
            notePlane.position.x=whiteKeys[i].position.x;
            notePlane.position.y=whiteKeyStavePositionY[i];
            notePlane.position.z=stavePositionZ+1.1;
            notePlane.material.transparent=true;
            notePlane.visible=false;
            notePlane.name='notePlane'+i;
            staveNotePlanes.push(notePlane);
            scene.add(notePlane);
        }

        for(i=0;i<52;i++)
        {
            notePlane=new THREE.Mesh(new THREE.PlaneGeometry(4,4),
                    new THREE.MeshBasicMaterial({color:0xffffff,map:THREE.ImageUtils.loadTexture('stavePictures/flatRed.png')}));
            notePlane.position.x=whiteKeys[i].position.x-4;
            notePlane.position.y=whiteKeyStavePositionY[i];
            notePlane.position.z=stavePositionZ+1.2;
            notePlane.material.transparent=true;
            notePlane.visible=false;
            notePlane.name='flat'+i;
            flats.push(notePlane);
            scene.add(notePlane);
        }


        for(i=0;i<52;i++)
        {
            notePlane=new THREE.Mesh(new THREE.PlaneGeometry(4,4),
                    new THREE.MeshBasicMaterial({color:0xffffff,map:THREE.ImageUtils.loadTexture('stavePictures/sharpRed.png')}));
            notePlane.position.x=whiteKeys[i].position.x-4;
            notePlane.position.y=whiteKeyStavePositionY[i];
            notePlane.position.z=stavePositionZ+1.2;
            notePlane.material.transparent=true;
            notePlane.visible=false;
            notePlane.name='flat'+i;
            sharps.push(notePlane);
            scene.add(notePlane);
        }

    }
    //        五线谱可视化
    function showStave()
    {
        stavePlane.visible=true;
        for(i=0;i<11;i++)
        {
            stavePlaneLines[i].visible=true;
        }
        for(i=0;i<staveNotePlanes.length;i++)
        {
            staveNotePlanes[i].visible=true;
            staveNotePlanes[i].material.color.setHex(0xffffff);
        }
        FclefPlane.visible=true;
        GclefPlane.visible=true;
    }
    //        五线谱不可见
    function hideStave()
    {
        stavePlane.visible=false;
        for(i=0;i<11;i++)
        {
            stavePlaneLines[i].visible=false;
        }
        for(i=0;i<52;i++)
        {
            staveNotePlanes[i].visible=false;
        }
        FclefPlane.visible=false;
        GclefPlane.visible=false;
    }

    //五线谱学习时琴键按下
    function staveKeyDown(keynum) {
        var num
        if(keynum>200&&keynum<=252)
        {
            staveNotePlanes[keynum-201].material.color.setHex(0xff0000);
        }
        else if(keynum>100&&keynum<=136)
        {
            if(blackKeyMode==0)
            {
                num=findBlackKeyFlatAndSharpNum(keynum,0)
                flats[num].visible=true;
                staveNotePlanes[num].material.color.setHex(0xff0000);
            }
            else if(blackKeyMode==1)
            {
                num=findBlackKeyFlatAndSharpNum(keynum,1)
                sharps[num].visible=true;
                staveNotePlanes[num].material.color.setHex(0xff0000);
            }
        }
    }

    //五线谱学习时琴键抬起
    function staveKeyUp(keynum) {
        var num;
        if(keynum>200&&keynum<=252)
        {
            staveNotePlanes[keynum-201].material.color.setHex(0xffffff);
        }
        else if(keynum>100&&keynum<=136)
        {
            if(blackKeyMode==0)
            {
                num=findBlackKeyFlatAndSharpNum(keynum,0)
                flats[num].visible=false;
                staveNotePlanes[num].material.color.setHex(0xffffff);
            }
            else if(blackKeyMode==1)
            {
                num=findBlackKeyFlatAndSharpNum(keynum,1)
                sharps[num].visible=false;
                staveNotePlanes[num].material.color.setHex(0xffffff);
            }
        }
    }

    //返回黑键对应的音符序号
    function findBlackKeyFlatAndSharpNum(keynum,num)
    {
        if(blackKeyFlatAndSharpNum.length==0)
        {
            initBlackKeyFlatAndSharpNum()
        }
        if(num==0)
        {
            return blackKeyFlatAndSharpNum[keynum-101]+1;
        }
        else if(num==1)
        {
            return blackKeyFlatAndSharpNum[keynum-101];
        }
    }

    //初始化黑键音符C大调降调模式对应音符序号
    function initBlackKeyFlatAndSharpNum()
    {
        var i,j;
        for(i=1;i<=52;i++)
        {
            j=i%7;
            blackKeyFlatAndSharpNum.push(i-1);
            if(j==1||j==4)
            {
                i++;
            }
        }
    }


    showStave();

</script>
</body>
</html>