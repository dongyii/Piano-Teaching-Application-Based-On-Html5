<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>自由弹奏</title>
    <!--样式-->
    <style>
        body{
            margin:0px;
            overflow: hidden;
        }
    </style>
    <!--引入THREE.js-->
    <script src="three.js"></script>
    <script src="OrbitControls.js"></script>
    <script src="OBJLoader.js"></script>
    <script src="MTLLoader.js"></script>
    <script src="myBoxGeometry.js"></script>
    <script src="Bird.js"></script>
    <script src="stats.min.js"></script>
</head>
<body>
<div id="container"></div>

<script>

    // Based on http://www.openprocessing.org/visuals/?visualID=6910

    var Boid = function() {

        var vector = new THREE.Vector3(),
                _acceleration, _width = 500, _height = 500, _depth = 200, _goal, _neighborhoodRadius = 100,
                _maxSpeed = 2, _maxSteerForce = 0.1, _avoidWalls = false;

        this.position = new THREE.Vector3();//位置
        this.velocity = new THREE.Vector3();//速度
        _acceleration = new THREE.Vector3();//加速度

        this.setGoal = function ( target ) {

            _goal = target;

        };
        this.setNeighborhoodRadius = function ( target ) {

            _neighborhoodRadius = target;

        };

        this.setAvoidWalls = function ( value ) {

            _avoidWalls = value;

        };

        this.setWorldSize = function ( width, height, depth ) {

            _width = width;
            _height = height;
            _depth = depth;

        };

        this.run = function ( boids ) {

            if ( _avoidWalls ) {

                vector.set( - _width, this.position.y, this.position.z );//x轴左边的一个位置点 或者说从原点到这个点的向量
                vector = this.avoid( vector );//产生一个远离这个位置点的向量
                vector.multiplyScalar( 5 );//远离的向量的大小乘以5倍
                _acceleration.add( vector );//给加速度加上这个远离向量

                vector.set( _width, this.position.y, this.position.z );
                vector = this.avoid( vector );
                vector.multiplyScalar( 5 );
                _acceleration.add( vector );

                vector.set( this.position.x, - _height, this.position.z );
                vector = this.avoid( vector );
                vector.multiplyScalar( 5 );
                _acceleration.add( vector );

                vector.set( this.position.x, _height, this.position.z );
                vector = this.avoid( vector );
                vector.multiplyScalar( 5 );
                _acceleration.add( vector );

                vector.set( this.position.x, this.position.y, - _depth );
                vector = this.avoid( vector );
                vector.multiplyScalar( 5 );
                _acceleration.add( vector );

                vector.set( this.position.x, this.position.y, _depth );
                vector = this.avoid( vector );
                vector.multiplyScalar( 5 );
                _acceleration.add( vector );

            }

            if ( Math.random() > 0.5 ) {

                this.flock( boids );

            }

            this.move();

        };

        this.flock = function ( boids ) {

            if ( _goal ) {

                _acceleration.add( this.reach( _goal, 0.005 ) );//接近目的坐标 向量长度乘以0.005倍

            }

            _acceleration.add( this.alignment( boids ) );
            _acceleration.add( this.cohesion( boids ) );
            _acceleration.add( this.separation( boids ) );

        };

        this.move = function () {

            this.velocity.add( _acceleration );//速度加上加速度

            var l = this.velocity.length();//判断速度的长度

            if ( l > _maxSpeed ) {

                this.velocity.divideScalar( l / _maxSpeed );

            }

            this.position.add( this.velocity );//按照速度移动
            _acceleration.set( 0, 0, 0 );//加速度归零

        };

        this.checkBounds = function () {

            if ( this.position.x >   _width ) this.position.x = - _width;//如果从x轴右边出界，则返回x轴最左侧
            if ( this.position.x < - _width ) this.position.x =   _width;//如果x从轴左边出界，则返回x轴最右侧
            if ( this.position.y >   _height ) this.position.y = - _height;//如果从y轴一侧出界，则返回y轴另一侧
            if ( this.position.y < - _height ) this.position.y =  _height;//如果从y轴一侧出界，则返回y轴另一侧
            if ( this.position.z >  _depth ) this.position.z = - _depth;//如果从z轴一侧出界，则返回z轴另一侧
            if ( this.position.z < - _depth ) this.position.z =  _depth;//如果从z轴一侧出界，则返回z轴另一侧

        };

        //

        this.avoid = function ( target ) {

            var steer = new THREE.Vector3();

            steer.copy( this.position );
            steer.sub( target );//得到一个远离target的引导向量

            steer.multiplyScalar( 1 / this.position.distanceToSquared( target ) );//距离越大 这个引导向量越短 受力越小

            return steer;

        };
        //驱逐函数 相对target来驱逐
        this.repulse = function ( target ) {

            var distance = this.position.distanceTo( target );//与驱逐物的距离

            if ( distance < 150 ) {

                var steer = new THREE.Vector3();

                steer.subVectors( this.position, target );//一个远离target的引导向量
                steer.multiplyScalar( 0.5 / distance );//距离越大 向量越短 即对加速度影响越小

                _acceleration.add( steer );//影响加速度

            }

        };

        this.reach = function ( target, amount ) {

            var steer = new THREE.Vector3();

            steer.subVectors( target, this.position );//得到一个接近target的引导向量
            steer.multiplyScalar( amount );//乘以amount倍

            return steer;

        };
//        结盟
        this.alignment = function ( boids ) {

            var boid, velSum = new THREE.Vector3(),
                    count = 0;

            for ( var i = 0, il = boids.length; i < il; i++ ) {

                if ( Math.random() > 0.6 ) continue;

                boid = boids[ i ];

                distance = boid.position.distanceTo( this.position );

                if ( distance > 0 && distance <= _neighborhoodRadius ) {

                    velSum.add( boid.velocity );
                    count++;

                }

            }

            if ( count > 0 ) {

                velSum.divideScalar( count );

                var l = velSum.length();

                if ( l > _maxSteerForce ) {

                    velSum.divideScalar( l / _maxSteerForce );

                }

            }

            return velSum;//以百分之60的概率向所有的成员靠近

        };
//        凝聚力
        this.cohesion = function ( boids ) {

            var boid, distance,
                    posSum = new THREE.Vector3(),
                    steer = new THREE.Vector3(),
                    count = 0;

            for ( var i = 0, il = boids.length; i < il; i ++ ) {

                if ( Math.random() > 0.6 ) continue;

                boid = boids[ i ];
                distance = boid.position.distanceTo( this.position );

                if ( distance > 0 && distance <= _neighborhoodRadius ) {

                    posSum.add( boid.position );
                    count++;

                }

            }

            if ( count > 0 ) {

                posSum.divideScalar( count );

            }

            steer.subVectors( posSum, this.position );

            var l = steer.length();

            if ( l > _maxSteerForce ) {

                steer.divideScalar( l / _maxSteerForce );

            }

            return steer;

        };
//        分离
        this.separation = function ( boids ) {

            var boid, distance,
                    posSum = new THREE.Vector3(),
                    repulse = new THREE.Vector3();

            for ( var i = 0, il = boids.length; i < il; i ++ ) {

                if ( Math.random() > 0.6 ) continue;

                boid = boids[ i ];
                distance = boid.position.distanceTo( this.position );

                if ( distance > 0 && distance <= _neighborhoodRadius ) {

                    repulse.subVectors( this.position, boid.position );//得到一个远离的向量
                    repulse.normalize();//变成单位向量
                    repulse.multiplyScalar( 10 );
                    repulse.divideScalar( distance );//距离越小 分离的力量越大
                    posSum.add( repulse );

                }

            }

            return posSum;
        }
        //避开target点 范围n
        this.avoidPoint = function( target ,n)
        {
            if(target==null)return;

            vector.set( target.x+ n , this.position.y, this.position.z );//x轴左边的一个位置点 或者说从原点到这个点的向量
            vector = this.avoid( vector );//产生一个远离这个位置点的向量
            vector.multiplyScalar( 3 );//远离的向量的大小乘以5倍
            _acceleration.add( vector );//给加速度加上这个远离向量

            vector.set( target.x-n, this.position.y, this.position.z );
            vector = this.avoid( vector );
            vector.multiplyScalar( 3 );
            _acceleration.add( vector );

            vector.set( this.position.x, target.y+n, this.position.z );
            vector = this.avoid( vector );
            vector.multiplyScalar( 3 );
            _acceleration.add( vector );

            vector.set( this.position.x,target.y-n, this.position.z );
            vector = this.avoid( vector );
            vector.multiplyScalar( 3 );
            _acceleration.add( vector );

            vector.set( this.position.x, this.position.y, target.z+n );
            vector = this.avoid( vector );
            vector.multiplyScalar( 3 );
            _acceleration.add( vector );

            vector.set( this.position.x, this.position.y, target.z-n );
            vector = this.avoid( vector );
            vector.multiplyScalar( 3 );
            _acceleration.add( vector );
        }
        this.checkAvoidPointBounds = function (target,n) {
            if(target==null)return;
            vector=vector.sub(this.position,target.position);
            if((vector.x*vector.x+vector.y*vector.y+vector.z*vector.z)<3*n*n)//如果在不该靠近的范围内
            {
                this.position.x += n;
                this.position.y += n;
                this.position.z += n;
            }

        };

    }

</script>
<script>
    //一些全局变量
    //绘制白琴键和黑琴键
    var blackKeyMode=0;//黑键模式 1为#升号 0为b降号
    var blackKeyModesChooseButton;//黑键模式选择按钮

    var blackKeyHeight=3;//黑琴键高度
    var blackKeyWidth=blackKeyHeight*1.5;//黑琴键宽度 等于高度的1.5倍
    var blackKeyDepth=blackKeyHeight*10;//黑琴键长度 等于高度的10倍
    var whiteKeyHeight=blackKeyHeight;//白琴键高度 等于黑键的高度
    var whiteKeyWidth=blackKeyHeight*2;//白琴键宽度 等于黑键的高度的2倍
    var whiteKeyDepth=blackKeyDepth*3/2;//白琴键长度 等于黑键的长度的二分之三倍
    var blackKey = new THREE.BoxGeometry(blackKeyWidth,blackKeyHeight,blackKeyDepth);//黑键形状
    var whiteKey = new THREE.BoxGeometry(whiteKeyWidth,whiteKeyHeight,whiteKeyDepth);//白键形状
    var blackKeyMesh=new THREE.MeshLambertMaterial({color:0x000000});//黑键材质
    var whiteKeyMesh = new THREE.MeshBasicMaterial({color:0xffffff});//白键材质
    var whiteKeyStartPosition=-154;//左边第一个白琴键的位置
    var blackKeyStartPosition=whiteKeyStartPosition+whiteKeyWidth/2;//左边第一个黑琴键的位置


    var px=whiteKeyStartPosition;//左边第一个白琴键x坐标
    var py=0;//白琴键y坐标
    var pz=0;//白琴键z坐标
    var KeyKind;//鼠标点击时或移动时，保存最近一个被点击或指向的琴键的类型，便于在鼠标放开或移动时做相应处理
    var KeyNum;//鼠标点击时或移动时，保存最近一个被点击或指向的琴键的序号，便于在鼠标放开或移动时做相应处理
    var mousedown=0;//反映鼠标是否按下，0没按下，1已按下。

    //初始化键盘按键对应的琴键
    var keyFunction=[];

    var wKey;
    var objects=[];//可点击的物体们
    var whiteKeys=[];//白键们
    var blackKeys=[];//黑键们
    var whiteKeysEdges=[];//白键的边框们
    var edges=[];//边框们

    var blackKeyBoxs=[];//黑琴键按键提示盒子
    var whiteKeyBoxs=[];//白琴键按键提示盒子

    //自定义琴键的一些全局变量
    var keyboardSelfDefining=0;//是否正在自定义琴键 0否 1是
    var keyboardSelfDefineChoosed=0;//是否已经选中要定义的琴键 0否 1是
    var keyboardSelfDefineChoosedKey;//用户选中要进行自定义的琴键Object
    var keyboardRecoverButton;//琴键按键恢复初始化设置

    var keyboardkeyDown=[];

    //        加入飞鸟
    var SCREEN_WIDTH = window.innerWidth,
            SCREEN_HEIGHT = window.innerHeight,
            SCREEN_WIDTH_HALF = SCREEN_WIDTH  / 2,
            SCREEN_HEIGHT_HALF = SCREEN_HEIGHT / 2;
    var birdsGoal=new THREE.Vector3(0,30,0);
    var birds, bird;
    var neighborhoodRadius=100;

    var boid, boids;
    var refuse;
    var stats = new Stats();
    document.getElementById( 'container' ).appendChild(stats.dom);

    var birdButton;//关闭/开启飞鸟按钮
    var birdClosed=0;//是否关闭了飞鸟

    var waterfallVelocity=3;//控制音长 与飞鸟速度改变相关

    //    返回上一个页面按钮
    var backButton;

    //五线谱
    var whiteKeyStavePositionY=[];
    var blackKeyStavePositionY=[];
    var staveCenterPositionY=40;




    //        初始化
    initAudio();
    initKey();
    //        创建场景
    var scene=new THREE.Scene();
    //        给场景设置背景
    scene.background = new THREE.CubeTextureLoader()
            .setPath( 'MilkyWay/' )
            .load( [ 'dark-s_px.jpg', 'dark-s_nx.jpg', 'dark-s_py.jpg', 'dark-s_ny.jpg', 'dark-s_pz.jpg', 'dark-s_nz.jpg' ] );
    //        创建灯光
    var ambientLight=new THREE.AmbientLight(0xffffff);
    scene.add(ambientLight);
    var pointlight=new THREE.PointLight(0xffffff);
    pointlight.position.set(500,500,500);
    scene.add(pointlight);
    //        创建照相机
    var camera=new THREE.PerspectiveCamera(45,window.innerWidth/window.innerHeight,1,5000);
    camera.position.set(0,100,160);
    camera.lookAt(scene.position);
    //        创建渲染器
    var renderer= new THREE.WebGLRenderer();
    renderer.setClearColor(0xf0f0f0);
    renderer.setSize(window.innerWidth,window.innerHeight);
    document.body.appendChild(renderer.domElement);
    //        渲染函数
    function render() {

        for ( var i = 0, il = birds.length; i < il; i++ ) {

            boid = boids[ i ];
            boid.setNeighborhoodRadius(neighborhoodRadius);
            boid.setGoal(birdsGoal)
            boid.run( boids );
            boid.avoidPoint(birdsGoal,5);
//                boid.checkAvoidPointBounds(birdsGoal,5);

            bird = birds[ i ];
            bird.position.copy( boids[ i ].position );
            color = bird.material.color;
            color -= ( camera.position.z - bird.position.z ) / 500;//越远的越暗 好像没啥用
//                color.g -= ( camera.position.z - bird.position.z ) / 1000;
//                color.b -=( camera.position.z - bird.position.z ) / 1000;
            bird.rotation.y = Math.atan2( - boid.velocity.z, boid.velocity.x );
            bird.rotation.z = Math.asin( boid.velocity.y / boid.velocity.length() );


            bird.phase = ( bird.phase + ( Math.max( 0, bird.rotation.z ) + 0.1 )  ) % 62.83;
            bird.geometry.vertices[ 5 ].y = bird.geometry.vertices[ 4 ].y = Math.sin( bird.phase ) * 5;




        }if(neighborhoodRadius<200)
        {
            neighborhoodRadius+=Math.random()*2;
        }
        if(neighborhoodRadius>100)
        {
            birdsGoal=null;
        }
        renderer.render(scene,camera);
    }
    //        初始化飞鸟
    initBirds();

    //        创建控制器
    var control=new THREE.OrbitControls(camera);
    control.addEventListener('change',render);
    //        动画控制函数
    function animate() {

        stats.begin();
        requestAnimationFrame(animate);
//        renderWaterfallCubes();
        render();
        stats.end();
    }
    animate();
    //        监听窗口大小改变
    window.addEventListener('resize',onWindowResize,false);
    function onWindowResize() {
        camera.aspect=window.innerWidth/window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth,window.innerHeight);
        render();
    }
    //        导入带材质的钢琴
    var onProgress=function (xhr) {
        if(xhr.lengthComputable){
            var persentComplete=xhr.loaded/xhr.total*100;
            console.log(Math.round(persentComplete,2)+'%downloaded');
        }
    };
    var onError=function (xhr) {
        console.log('fail to load mtl');
    };
    var mtlLoader=new THREE.MTLLoader();
    mtlLoader.load('PianoThree/PianoThree.mtl',function (objMtl) {
        var objLoader=new THREE.OBJLoader();
        objLoader.setMaterials(objMtl);
        objLoader.load('PianoThree/PianoThree.obj',function (obj) {
            obj.scale.set(0.2,0.2,0.2);
            obj.position.y=obj.position.y-147;
            obj.position.z=obj.position.z-115;
            scene.add(obj);
            objects.push(obj);
        })
    },onProgress,onError);



    //        绘制白琴键
    var whiteKeyNum=201;

    while(whiteKeyNum<=252){
        wKey=new THREE.Mesh(
                new THREE.myBoxGeometry(whiteKeyWidth,whiteKeyHeight,whiteKeyDepth),
                new THREE.MeshBasicMaterial({color:0xffffff}));//新建一个白键
        /*注意：
         不要写
         var wKey=new THREE.Mesh(whiteKey,whiteKeyMaterial);
         会导致点下一个白键的效果，等于所有白键都被点击
         */
        var edges = new THREE.EdgesHelper( wKey, 0xa0a0a0 );//给白键加一个边框
        scene.add(wKey);//将白键追加到场景中
        scene.add(edges);//将白键的边框加到场景中
        whiteKeysEdges.push(edges);//将白键的边框加到白键边框数组中
        objects.push(wKey);//将白键加到可被点击的物体数组中
        whiteKeys.push(wKey);//加入白键数组中
        wKey.num=whiteKeyNum; //设置琴键序号
        wKey.kind='whiteKey';//设置琴键类型为白键
        whiteKeyNum+=1; //下一个白键的序号
        wKey.position.x=px;//白键x坐标
        wKey.position.y=py;//白键y坐标
        wKey.position.z=pz;//白键z坐标
        px+=whiteKeyWidth+0.1; //下一个白键横坐标位置 0.1的琴键间隙
    }

    // //绘制黑琴键
    var px2=blackKeyStartPosition;
    var py2=py+2;
    var pz2=pz-5;
    var blackKeyNum=101;

    wKey=new THREE.Mesh(new THREE.BoxGeometry(
            blackKeyWidth,blackKeyHeight,blackKeyDepth),
            new THREE.MeshLambertMaterial({color:0x000000}));
    scene.add(wKey);
    objects.push(wKey);//将黑键加到可被点击的物体数组中
    blackKeys.push(wKey);//加入黑键数组中
    wKey.num=blackKeyNum;
    wKey.kind='blackKey';//设置琴键类型为黑键
    blackKeyNum+=1;
    wKey.position.x=px2;
    wKey.position.y=py2;
    wKey.position.z=pz2;
    px2+=whiteKeyWidth+0.1;
    px2+=whiteKeyWidth+0.1;

    for (var i = 7-1; i >= 0; i--) {
        for (var j = 1; j<=5; j++) {
            wKey=new THREE.Mesh(new THREE.BoxGeometry(
                    blackKeyWidth,blackKeyHeight,blackKeyDepth),
                    new THREE.MeshLambertMaterial({color:0x000000}));
            scene.add(wKey);
            wKey.num=blackKeyNum;
            blackKeyNum+=1;
            wKey.kind='blackKey';//设置琴键类型为黑键
            objects.push(wKey);//将黑键加到可被点击的物体数组中
            blackKeys.push(wKey);//加入黑键数组中
            wKey.position.x=px2;
            wKey.position.y=py2;
            wKey.position.z=pz2;
            px2+=whiteKeyWidth+0.1;
            if(j==2||j==5){
                px2+=whiteKeyWidth+0.1;
            }
        };
    }
    //        监听事件

    var raycaster=new THREE.Raycaster();
    var mouse=new THREE.Vector2();
    document.addEventListener('mousedown',onMouseDown,false);//监听鼠标按下事件
    document.addEventListener('mouseup',onMouseUp,false);//监听鼠标抬起事件
    document.addEventListener('mousemove',onMouseMove,false);//监听鼠标移动事件

    //        监听鼠标按下事件函数
    function onMouseDown (event) {
        event.preventDefault();


        if(keyboardSelfDefining==1)//如果正在进行鼠标自定义
        {
            keyboardSelfDefindingOnMouseDown(event);
        }
        else
        {
            playPianoOnMouseDown(event);
        }

    }
    //        监听鼠标抬起事件函数
    function onMouseUp (event) {
        event.preventDefault();

        mousedown=0;//反映鼠标没有按下
        var knum;
        if(keyboardSelfDefining==1)//如果正在自定义按键
        {
            ;//不做任何处理
        }
        else if(KeyNum)
        {
            if(KeyKind=='whiteKey')
            {
                knum=KeyNum-201;//根据琴键序号KeyNum查找白键序号
                whiteKeys[knum].material.color.setHex(0xffffff);//恢复白键原来的颜色
                           }
            else if(KeyKind=='blackKey')
            {
                knum=KeyNum-101;//根据琴键序号KeyNum查找黑键序号
                blackKeys[knum].material.color.setHex(0x000000);//恢复黑键原来的颜色
            }
            else
            {
            }

        }
        else
        {
        }
        render();
        mouseup=1;
        control.enabled=true;//开启控制器
    }

    //        监听鼠标移动事件函数
    function onMouseMove (event) {

        event.preventDefault();

        if(keyboardSelfDefining==1)//正在自定义琴键
        {
            ;//不作任何处理
        }
        else if(mousedown==1)
        {
            //将屏幕像素坐标转化成camare坐标
            mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

            raycaster.setFromCamera(mouse,camera);//mouse是鼠标的二维坐标，camera是射线起点处的相机，即把射线起点设置在camera的位置
            var intersects=raycaster.intersectObjects(objects);//objects是要被判断是否被射线穿过的物体们，objects是个数组，下标越小离射线起点越近
            if(intersects.length>0)
            {
                //是琴键 并且是有滑动到了另一个琴键上
                if(intersects[0].object.num && (intersects[0].object.num!=KeyNum)&&intersects[0].object.kind=='whiteKey'||intersects[0].object.kind=='blackKey')
                {
                    //处理前一个琴键。恢复颜色
                    if(mouseup==0)//如果mouseup==1 则无需处理
                    {
                        if(KeyKind=='whiteKey')
                        {
                            knum=KeyNum-201;
                            whiteKeys[knum].material.color.setHex(0xffffff);
                        }
                        else if(KeyKind=='blackKey')
                        {
                            knum=KeyNum-101;
                            blackKeys[knum].material.color.setHex(0x000000);
                        }
                        else
                        {
                            ;
                        }
                    }

                    //处理现在的琴键，播放声音，改变颜色
                    if(intersects[0].object.kind=='whiteKey'||intersects[0].object.kind=='blackKey')
                    {
                        control.enabled=false;
                        intersects[0].object.material.color.setHex(0xa0a0a0);
                        if(intersects[0].object.num)
                        {
                            playAudio(intersects[0].object.num);//播放对应序号琴键的声音
                        }
                        render();
                    }
                    else
                    {
                        ;
                    }
                    KeyKind=intersects[0].object.kind;//记录当前点击的类型
                    KeyNum=intersects[0].object.num;//记录当前序号

                }
                else//不是琴键
                {
                    ;
                }

            }
        }
    }

    //        音频初始化
    function initAudio()
    {
        for(var i=101;i<=136;i++)
        {
            var audio=document.createElement("audio");
            audio.id='myaudio'+i;
            document.body.appendChild(audio);
            var qianzhui='pianoKey/';
            var houzhui='.mp3';
            var source=qianzhui+i+houzhui;
            audio.src=source;
        }
        for(var i=201;i<=252;i++)
        {
            var audio=document.createElement("audio");
            audio.id='myaudio'+i;
            document.body.appendChild(audio);
            var qianzhui='pianoKey/';
            var houzhui='.mp3';
            var source=qianzhui+i+houzhui;
            audio.src=source;
        }
    }
    //        播放音频函数
    function playAudio ( name) {
        console.log(name)
        repulseBirdByKey(name);
        var aname='myaudio'+name;
        var myaudio=document.getElementById(aname);
        myaudio.stop();//如果原先已经在播放中，先结束播放
        myaudio.play();
    }
    //        瀑布流之播放音频函数
    function waterfallPlayAudio ( name)
    {
        repulseBirdByKey(name);
        console.log('waterfall'+name)
        var name1=name+200;
        var aname='myaudio'+name1;
        var myaudio=document.getElementById(aname);
        myaudio.stop();//如果原先已经在播放中，先结束播放
        myaudio.play();
    }
    //        结束音频播放函数
    HTMLAudioElement.prototype.stop = function()
    {
        this.pause();
        this.currentTime = 0.0;
    }
    //        停止播放音频函数
    function stopAudio ( name) {
        aname='myaudio'+name;
        if(name<10)
            name='0'+name;
        // var qianzhui='pianoKey/';
        // var houzhui='.mp3';
        // var source=qianzhui+name+houzhui;
        var myaudio=document.getElementById(aname);
        // myaudio.src=source;
        myaudio.stop();
    }

    //        给琴键添加键盘按键对应效果

    document.addEventListener('keydown',onKeyDown,false);
    document.addEventListener('keyup',onKeyUp,false);
    //        键盘按键与琴键的对应关系初始化
    function initKey () {
        var i;
        for(i=0;i<300;i++)
        {
            keyFunction[i]=0;
        }
        // keyFunction[键值]=对应音频（琴键）序号;
        // 第一行按键
        keyFunction[49]=233;// ! 和 1 按键
        keyFunction[50]=234;// @ 和 2 按键
        keyFunction[51]=124;// # 和 3 按键
        keyFunction[52]=235;// $ 和 4 按键
        keyFunction[53]=125;// % 和 5 按键
        keyFunction[54]=236;// ^ 和 6 按键
        keyFunction[55]=126;// & 和 7 按键
        keyFunction[56]=237;// * 和 8 按键
        keyFunction[57]=238;// ( 和 9 按键
        keyFunction[48]=127;// ) 和 0 按键
        keyFunction[189]=239;// _ 和 - 按键
        keyFunction[187]=128;// + 和 = 按键
        keyFunction[8]=240;// backspace 按键

        //第二行按键
        keyFunction[81]=114;//Q
        keyFunction[87]=115;//W
        keyFunction[69]=116;//E
        keyFunction[82]=224;//R
        keyFunction[84]=117;//T
        keyFunction[89]=118;//Y
        keyFunction[85]=226;//U
        keyFunction[73]=119;//I
        keyFunction[79]=120;//O
        keyFunction[80]=121;//P
        keyFunction[219]=231;// { 和 [ 按键
        keyFunction[221]=122;// } 和 ] 按键
        keyFunction[220]=123;// | 和 \ 按键

        //第三行按键
        keyFunction[65]=221;//A
        keyFunction[83]=222;//S
        keyFunction[68]=223;//D
        keyFunction[70]=224;//F
        keyFunction[71]=225;//G
        keyFunction[72]=226;//H
        keyFunction[74]=227;//J
        keyFunction[75]=228;//K
        keyFunction[76]=229;//L
        keyFunction[186]=230;//分号按键
        keyFunction[222]=231;//单引号按键
        keyFunction[13]=232;//回车键

        //第四行按键
        keyFunction[90]=110;//Z
        keyFunction[88]=215;//X
        keyFunction[67]=111;//C
        keyFunction[86]=216;//V
        keyFunction[66]=217;//B
        keyFunction[78]=112;//N
        keyFunction[77]=218;//M
        keyFunction[188]=113;// < 和 , 按键
        keyFunction[190]=219;// > 和 . 按键
        keyFunction[191]=220;// ? 和 / 按键
    }
    //        监听键盘按键的处理函数
    function onKeyDown (event) {
        var i=0;
        var num;
        kbnum=event.keyCode;
        if(kbnum==17){
            return;
        }
        if(keyboardkeyDown[kbnum]==1)
        {
            ;
        }
//            alert(kbnum);
        else if(keyboardSelfDefining==1)//正在自定义琴键
        {
            if(keyboardSelfDefineChoosed==1)//已经选中要定义的琴键
            {
                if(keyFunction[keyFunction[kbnum]==0])//如果没有定义过该按键
                {
                    console.log('can not self-define this keyboard key, please choose an other one');//
                }
                else
                {
                    ;//修改键盘按键提示图片
                    if(keyFunction[kbnum]!=-1&&keyFunction[kbnum]!=0)//如果该按键原来对应的琴键没有被置空 且按键是合法按键
                    {
                        if(keyFunction[kbnum]>200&&keyFunction[kbnum]<=252)//判断是按键原来对应的是白键
                        {
                            whiteKeyBoxs[keyFunction[kbnum]-201].material.map=THREE.ImageUtils.loadTexture('KeyboardPictures/null.png');// 按键原来对应的提示盒子设置空白图片

                        }
                        else if(keyFunction[kbnum]>100&&keyFunction[kbnum]<=136)
                        {
                            blackKeyBoxs[keyFunction[kbnum]-101].material.map=THREE.ImageUtils.loadTexture('KeyboardPictures/null.png');// 按键原来对应的提示盒子设置空白图片


                        }
                        console.log('set '+keyFunction[kbnum]+'KeyboardPicture null')
                    }

                    ;// 按键原来对应的提示盒子设置空
//                        现在按下的琴键的原来对应的按键设置空
                    for(i=0;i<300;i++)
                    {
                        if(keyFunction[i]==keyboardSelfDefineChoosedKey.num)
                        {
                            keyFunction[i]=-1;
                        }
                    }
                    ;//按键现在对应的提示盒子设置图片

                    keyFunction[kbnum]=keyboardSelfDefineChoosedKey.num;//修改键盘按键对应音频
                    var pictureSrc='KeyboardPictures/'+kbnum+'.png';
                    if(keyFunction[kbnum]>200&&keyFunction[kbnum]<=252)//判断是按键现在对应的是白键
                    {
                        whiteKeyBoxs[keyFunction[kbnum]-201].material.map=THREE.ImageUtils.loadTexture(pictureSrc);// 按键现在对应的提示盒子设置图片
                        console.log('set whiteKeyBoxs '+keyFunction[kbnum]+''+pictureSrc);
                    }
                    else if(keyFunction[kbnum]>100&&keyFunction[kbnum]<=136)
                    {
                        blackKeyBoxs[keyFunction[kbnum]-101].material.map=THREE.ImageUtils.loadTexture(pictureSrc);// 按键现在对应的提示盒子设置图片
                        console.log('set blackKeyBoxs '+keyFunction[kbnum]+''+pictureSrc);
                    }
                }
            }
        }
        else
        {
            keynum=keyFunction[kbnum];//琴键序号
            if(keynum!=0&&keynum!=-1)
            {
                playAudio(keynum);
                console.log('OnKeyDown playAudio '+keynum)
                if(keynum>200&&keynum<253)
                {
                    KeyBoardKeyKind='whiteKey';
                    num=keynum-201;
                    whiteKeys[num].material.color.setHex(0xa0a0a0);
                    for(i=0;i<300;i++)
                    {
                        if(keyFunction[i]==num)
                        {
                            keyFunction[i]
                        }
                    }
                }
                else if(keynum>100&&keynum<137)
                {
                    KeyBoardKeyKind='blackKey';
                    num=keynum-101;
                    blackKeys[num].material.color.setHex(0xa0a0a0);
                }
                if(waterfallCubesMode==1||waterfallCubesMode==2)//评分模式 引导练习模式 都需要将点击的琴键记录
                {
                    waterfallClickedAmount++;
                    if(KeyBoardKeyKind=='whiteKey')
                    {
                        waterfallJudgings.push(whiteKeys[num]);
                    }
                    else if(KeyBoardKeyKind=='blackKey')
                    {
                        waterfallJudgings.push(blackKeys[num]);
                    }
                }

                render();

            }
            else
            {
                // alert(i);
            }

        }
        keyboardkeyDown[kbnum]=1;

    }
    //        监听键盘按键抬起的处理函数
    function onKeyUp (event) {
        // event.preventDefault();
        var i=0;
        var num;
        kbnum=event.keyCode;
        keyboardkeyDown[kbnum]=0;//标志抬起
        keynum=keyFunction[kbnum];//琴键序号
        if(keynum!=0)
        {
            if(keynum>200&&keynum<253)
            {
                KeyBoardKeyKind='whiteKey';
                num=keynum-201;
                whiteKeys[num].material.color.setHex(0xffffff);

            }
            else if(keynum>100&&keynum<137)
            {
                KeyBoardKeyKind='blackKey';
                num=keynum-101;
                blackKeys[num].material.color.setHex(0x000000);
            }
            render();
        }
        else
        {
            // alert(i);
        }
    }
    //        添加键盘按键提示方块
    //添加白色琴键对应键盘按键提示方块
    var whiteKeyPictureNum=201;//白色琴键对应键盘提示方块的编号
    var wKeyBox;//白色琴键对应键盘提示方块
    var px3=whiteKeyStartPosition;//左边第一个白色琴键对应键盘按键提示方块的x坐标
    var py3=py-5;//白色琴键对应键盘提示方块的y坐标
    var pz3=pz+19;//白色琴键对应键盘提示方块的z坐标

    for(whiteKeyPictureNum=201;whiteKeyPictureNum<=252;whiteKeyPictureNum++){
        wKeyBox=new THREE.Mesh(
                new THREE.BoxGeometry(whiteKeyWidth,whiteKeyWidth,whiteKeyWidth),
                new THREE.MeshLambertMaterial({color:0x99efef,map:THREE.ImageUtils.loadTexture('KeyboardPictures/null.png')}));//新建一个白键按键提示盒子
        wKeyBox.material.transparent=true;
        scene.add(wKeyBox);//将白键按键提示盒子追加到场景中
        objects.push(wKeyBox);//将白键按键提示盒子加到可被点击的物体数组中
        whiteKeyBoxs.push(wKeyBox);//加入白键按键提示盒子数组中
        wKeyBox.num=whiteKeyPictureNum; //设置白键按键提示盒子序号
        wKeyBox.kind='whiteKeyBox';//设置琴键类型为白键按键提示盒子
//            whiteKeyPictureNum+=1; //下一个白键按键提示盒子的序号
        wKeyBox.position.x=px3;//白键按键提示盒子x坐标
        wKeyBox.position.y=py3;//白键按键提示盒子y坐标
        wKeyBox.position.z=pz3;//白键按键提示盒子z坐标
        px3+=whiteKeyWidth+0.1; //下一个白键横坐标位置 0.1的琴键间隙
    }

    //绘制黑琴键按键提示盒子
    var px4=blackKeyStartPosition;//左边第一个黑色琴键按键提示盒子的x坐标
    var py4=py+3.5+blackKeyWidth;
    var pz4=pz-27.5;
    var blackKeyBoxNum=101;
    var bKeyBox;

    bKeyBox=new THREE.Mesh(new THREE.BoxGeometry(
            blackKeyWidth,blackKeyWidth,blackKeyWidth),
            new THREE.MeshLambertMaterial({color:0x99efef,map:THREE.ImageUtils.loadTexture('KeyboardPictures/null.png')}));
    scene.add(bKeyBox);
    objects.push(bKeyBox);//将黑键按键提示盒子加到可被点击的物体数组中
    blackKeyBoxs.push(bKeyBox);//加入黑键按键提示盒子数组中
    bKeyBox.num=blackKeyBoxNum;
    bKeyBox.kind='blackKeyBox';//设置琴键类型为黑键提示盒子
    bKeyBox.material.transparent=true;
    blackKeyBoxNum+=1;
    bKeyBox.position.x=px4;
    bKeyBox.position.y=py4;
    bKeyBox.position.z=pz4;
    px4+=whiteKeyWidth+0.1;
    px4+=whiteKeyWidth+0.1;

    for (var i = 7-1; i >= 0; i--)
    {
        for (var j = 1; j<=5; j++) {
            bKeyBox=new THREE.Mesh(new THREE.BoxGeometry(
                    blackKeyWidth,blackKeyWidth,blackKeyWidth),
                    new THREE.MeshLambertMaterial({color:0x99efef,map:THREE.ImageUtils.loadTexture('KeyboardPictures/null.png')}));
            scene.add(bKeyBox);
            bKeyBox.num=blackKeyBoxNum;
            blackKeyBoxNum+=1;
            bKeyBox.kind='blackKeyBox';//设置琴键类型为黑键
            objects.push(bKeyBox);//将黑键加到可被点击的物体数组中
            blackKeyBoxs.push(bKeyBox);//加入黑键数组中
            bKeyBox.material.transparent=true;
            bKeyBox.position.x=px4;
            bKeyBox.position.y=py4;
            bKeyBox.position.z=pz4;
            px4+=whiteKeyWidth+0.1;
            if(j==2||j==5){
                px4+=whiteKeyWidth+0.1;
            }
        };
    }
    //        设置键盘按键提示盒子为彩色
    function initKeyBoxsColor()
    {
        var i=0,j=0;
        while(i<whiteKeyBoxs.length)
        {
            switch(j)
            {
                case 0:whiteKeyBoxs[i].material.color.setHex(0x0044ff);break;//靛色
                case 1:whiteKeyBoxs[i].material.color.setHex(0x8b00ff);break;//紫色
                case 2:whiteKeyBoxs[i].material.color.setHex(0xff0000);break;//红色
                case 3:whiteKeyBoxs[i].material.color.setHex(0xff7f00);break;//橙色
                case 4:whiteKeyBoxs[i].material.color.setHex(0xffff00);break;//黄色
                case 5:whiteKeyBoxs[i].material.color.setHex(0x00cf00);break;//绿色
                case 6:whiteKeyBoxs[i].material.color.setHex(0x0088ff);break;//蓝色
            }
            j=(j+1)%7;
            i++;
        }
        i=0;
        j=0;
        while(i<blackKeyBoxs.length)
        {
            switch(j)
            {
                case 0:blackKeyBoxs[i].material.color.setHex(0x8b00ff);break;//紫色
                case 1:blackKeyBoxs[i].material.color.setHex(0xff0000);break;//红色
                case 2:blackKeyBoxs[i].material.color.setHex(0xff7f00);break;//橙色
                case 3:blackKeyBoxs[i].material.color.setHex(0xffff00);break;//黄色
                case 4:blackKeyBoxs[i].material.color.setHex(0x00cf00);break;//绿色
            }
            j=(j+1)%5;
            i++;
        }
    }

    //初始化白色琴键按键提示盒子的图片
    function updateBoxsPicture() //键盘按键提示盒子图片更新
    {
        var boxImgName;//图片名字
        var num;
        for(var i=0;i<250;i++)
        {
            if(keyFunction[i]!=0)
            {
                if(keyFunction[i]>=201&&keyFunction[i]<253)
                {
                    boxImgName='KeyboardPictures/'+i+'.png';
                    num=keyFunction[i]-201;
                    whiteKeyBoxs[num].material.map=THREE.ImageUtils.loadTexture(boxImgName);
                }
                else if(keyFunction[i]>100&&keyFunction[i]<137)
                {
                    boxImgName='KeyboardPictures/'+i+'.png';
                    num=keyFunction[i]-101;
                    blackKeyBoxs[num].material.map=THREE.ImageUtils.loadTexture(boxImgName);
                }
            }
        }
    }
    updateBoxsPicture();


    //         添加键盘自定义按钮
    var keyboardSelfDefineCube=new THREE.Mesh(
            new THREE.myBoxGeometry(20,20,20)
            ,new THREE.MeshLambertMaterial({color:0xffffff,map:THREE.ImageUtils.loadTexture('ButtonPictures/keyboardSelfDefine.png')})
    )
    keyboardSelfDefineCube.position.set(-15,40,pz-54);
    scene.add(keyboardSelfDefineCube);
    objects.push(keyboardSelfDefineCube);
    keyboardSelfDefineCube.kind='keyboardSelfDefineCube';
    function clickKeyboardSelfDefineButton()
    {
        if(keyboardSelfDefineChoosedKey!=null)
        {
            keyboardSelfDefineKeyUp(keyboardSelfDefineChoosedKey);
        }
        if(keyboardSelfDefining==1)//如果正在进行键盘按键琴键自定义
        {
            keyboardSelfDefining=0;
            keyboardSelfDefineCube.material.map=THREE.ImageUtils.loadTexture('ButtonPictures/keyboardSelfDefine.png');

            console.log('1')
        }
        else
        {
            keyboardSelfDefining=1;
            keyboardSelfDefineCube.material.map=THREE.ImageUtils.loadTexture('ButtonPictures/endKeyboardSelfDefine.png');

            if(keyboardSelfDefineChoosed==1)
            {
                keyboardSelfDefineKeyUp(keyboardSelfDefineChoosedKey);
            }
            console.log('2')
        }
    }
    //        自定义键盘按键时，琴键按下
    function keyboardSelfDefineKeyDown(key)
    {
        if(keyboardSelfDefineChoosed==1)
        {
            keyboardSelfDefineKeyUp(keyboardSelfDefineChoosedKey);
        }
        if(key.num>200&&key.num<=252)//白键
        {
            whiteKeys[key.num-201].material.color.setHex(0x8f0000);
            playAudio(key.num);
            keyboardSelfDefineChoosedKey=key;
        }
        else if(key.num>100&&key.num<=136)//黑键
        {
            blackKeys[key.num-101].material.color.setHex(0x8f0000);
            playAudio(key.num);
            keyboardSelfDefineChoosedKey=key;
        }
        keyboardSelfDefineChoosed=1;
    }
    //        自定义键盘按键时，琴键抬起
    function keyboardSelfDefineKeyUp(key)
    {
        if(key.num>200&&key.num<=252)//白键
        {
            whiteKeys[key.num-201].material.color.setHex(0xffffff);
        }
        else if(key.num>100&&key.num<=136)//黑键
        {
            blackKeys[key.num-101].material.color.setHex(0x000000);
        }
        ;
    }
    //        自由弹奏时，监听鼠标按下事件
    function playPianoOnMouseDown(event)
    {
        mouseup=0;
        //将屏幕像素坐标转化成camare坐标
            touchEvent=0;
            mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;

        raycaster.setFromCamera(mouse,camera);//mouse是鼠标的二维坐标，camera是射线起点处的相机，即把射线起点设置在camera的位置
        var intersects=raycaster.intersectObjects(objects);//objects是要被判断是否被射线穿过的物体们，objects是个数组，下标越小离射线起点越近

        if(intersects.length>0)//点击到了物体
        {
            if(intersects[0].object.kind=='whiteKey'||intersects[0].object.kind=='blackKey')//判断是否钢琴键
            {
                control.enabled=false;//控制器关闭
                KeyKind=intersects[0].object.kind;//记录当前点击的琴键类型
                intersects[0].object.material.color.setHex(0xa0a0a0);//改变颜色
                if(intersects[0].object.num)//检查是否拥有num属性
                {
                    KeyNum=intersects[0].object.num;//记录当前琴键序号
                    playAudio(intersects[0].object.num);//播放对应音频
                    console.log('自由弹奏琴键序号：'+intersects[0].object.num)
                }

            }
            else if(intersects[0].object.kind=='whiteKeyBox'||intersects[0].object.kind=='blackKeyBox')//点击到按键提示盒子
            {
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }
            else if(intersects[0].object.kind=='keyboardSelfDefineCube')//点击到了键盘自定义方块按钮
            {
                clickKeyboardSelfDefineButton();
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }
            else if(intersects[0].object.name=='birdButton')//点击到关闭/开启飞鸟按钮
            {
                clickBirdButton();
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }
            else if(intersects[0].object.name=='backButton')//点击到了返回按钮
            {
                clickBackButton()
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }
            else if(intersects[0].object.name=='keyboardRecoverButton')//点击到了琴键恢复初始设置按钮
            {
                keyboardRecover();
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }
            else
            {
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }

        }
        else//没有点击到可点击的物体
        {
        }
        mousedown=1;//反映鼠标已经按下
    }
    //        自定义琴键按键时，监听鼠标按键按下
    function keyboardSelfDefindingOnMouseDown(event)
    {
        //将屏幕像素坐标转化成camare坐标
        console.log('touched')
            touchEvent=0;
            mouse.x = ( event.clientX / renderer.domElement.clientWidth ) * 2 - 1;
            mouse.y = - ( event.clientY / renderer.domElement.clientHeight ) * 2 + 1;


        raycaster.setFromCamera(mouse,camera);//mouse是鼠标的二维坐标，camera是射线起点处的相机，即把射线起点设置在camera的位置
        var intersects=raycaster.intersectObjects(objects);//objects是要被判断是否被射线穿过的物体们，objects是个数组，下标越小离射线起点越近

        if(intersects.length>0)//点击到了物体
        {
            if(intersects[0].object.kind=='whiteKey'||intersects[0].object.kind=='blackKey')//判断是否钢琴键
            {
                control.enabled=false;//控制器关闭
                keyboardSelfDefineKeyDown(intersects[0].object);
                console.log('自定义琴键弹奏琴键序号'+intersects[0].object.num)
            }
            else if(intersects[0].object.kind=='whiteKeyBox'||intersects[0].object.kind=='blackKeyBox')//点击到按键提示盒子
            {
                if(keyboardSelfDefineChoosed==1)
                {
                    keyboardSelfDefineChoosed=0;
                    keyboardSelfDefineKeyUp(keyboardSelfDefineChoosedKey);
                }
            }
            else if(intersects[0].object.kind=='keyboardSelfDefineCube')//点击到了键盘自定义方块按钮
            {
                clickKeyboardSelfDefineButton();
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }
            else if(intersects[0].object.name=='birdButton')//点击到关闭/开启飞鸟按钮
            {
                clickBirdButton();
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }
            else if(intersects[0].object.name=='backButton')//点击到了返回按钮
            {
                clickBackButton()
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }
            else if(intersects[0].object.name=='keyboardRecoverButton')//点击到了琴键恢复初始设置按钮
            {
                keyboardRecover();
                KeyKind=intersects[0].object.kind;//记录当前点击的类型
                KeyNum=intersects[0].object.num;//记录当前序号
            }
        }
        else//没有点击到物体
        {
            if (keyboardSelfDefineChoosed == 1) {
                keyboardSelfDefineChoosed = 0;
                keyboardSelfDefineKeyUp(keyboardSelfDefineChoosedKey);
            }
        }
        mousedown=1;//反映鼠标已经按下
    }

    //        初始化键盘按键是否按下的标志数组
    function initKeyboardKeyDown()
    {
        var i=0;
        for(i=0;i<300;i++)
        {
            keyboardkeyDown[i]=0;
        }
    }
    initKeyboardKeyDown();

    //初始化飞鸟
    function initBirds()
    {
        birds = [];
        boids = [];

        for ( var i = 0; i < 100; i ++ ) {
            boid = boids[ i ] = new Boid();
            boid.position.x = Math.random() * 400 - 200;
            boid.position.y = Math.random() * 400 - 200;
            boid.position.z = Math.random() * 400 - 200;
            boid.velocity.x = Math.random() * 2 - 1;
            boid.velocity.y = Math.random() * 2 - 1;
            boid.velocity.z = Math.random() * 2 - 1;
            boid.setAvoidWalls( true );
            boid.setWorldSize( 500, 500, 400 );
            bird = birds[ i ] = new THREE.Mesh( new Bird(), new THREE.MeshLambertMaterial( { color: 0xEE3A8C, side: THREE.DoubleSide } ) );
            bird.verticesNeedUpdate=true;
            bird.elementsNeedUpdate=true;
            bird.phase = Math.floor( Math.random() * 62.83 );
            scene.add( bird );
        }


        renderer.setPixelRatio( window.devicePixelRatio );

    }


    function repulseBirdByKey(num)
    {
        var vector = new THREE.Vector3( 0, 0, 0 );
        birdsGoal= new THREE.Vector3(0,30,0);

        if(num>200&&num<=252)
        {
            vector.x=num;
            vector.y=Math.random();
            birdsGoal.x=whiteKeys[num-201].position.x;
            birdsGoal.y=whiteKeyStavePositionY[num-201];
            birdsGoal.z=Math.random()*20-10;
        }
        else if(num>100&&num<=136)
        {
            vector.x=num;
            vector.y=Math.random();
            birdsGoal.x=whiteKeys[num-101].position.x;
            birdsGoal.z=Math.random()*20-10;
        }
        for ( var i = 0, il = boids.length; i < il; i++ ) {

            if ( Math.random() > 0.6 ) continue;
            boid = boids[ i ];

            vector.z = boid.position.z;
            boid.repulse( vector );
            boid.setGoal(birdsGoal);
        }
        if(neighborhoodRadius>100)
                neighborhoodRadius=100;

        if(neighborhoodRadius>20)
        {
            neighborhoodRadius=Math.floor(neighborhoodRadius*(waterfallVelocity+3)/(waterfallVelocity+3));
        }

    }

    //        关闭/开启飞鸟按钮
    birdButton=new THREE.Mesh(
            new THREE.BoxGeometry(20,20,20),
            new THREE.MeshLambertMaterial({color:0xffffff,map:THREE.ImageUtils.loadTexture('ButtonPictures/closeBirds.png')}));
    birdButton.position.set(10,40,-54);
    birdButton.name='birdButton';
    scene.add(birdButton);
    objects.push(birdButton);
    //    点击birdButton的处理函数
    function clickBirdButton()
    {
        if(birdClosed==0)
        {
            birdButton.material.map=THREE.ImageUtils.loadTexture('ButtonPictures/openBirds.png');
            closeBirds();
            birdClosed=1;
        }
        else {
            birdButton.material.map=THREE.ImageUtils.loadTexture('ButtonPictures/closeBirds.png');
            randomBirds();
            openBirds();
            birdClosed=0;
        }
    }
    //让鸟儿不可见
    function closeBirds()
    {
        for(var i=0;i<birds.length;i++)
        {
            birds[i].visible=false;
        }
    }
    //    让鸟儿可见
    function openBirds()
    {
        for(var i=0;i<birds.length;i++)
        {
            birds[i].visible=true;
        }
    }
    //        打乱鸟儿的位置
    function randomBirds()
    {
        for(var i=0;i<birds.length;i++)
        {
            birds[i].position.x=Math.random()*400-200;
            birds[i].position.y=Math.random()*400-200;
            birds[i].position.z=Math.random()*400-200;
        }
    }
    backButton=new THREE.Mesh(
            new THREE.BoxGeometry(20,20,20),
            new THREE.MeshLambertMaterial({color:0xffffff,map:THREE.ImageUtils.loadTexture('ButtonPictures/back.png')}));
    backButton.position.set(35,40,-54);
    backButton.name='backButton';
    scene.add(backButton);
    objects.push(backButton);
    function clickBackButton()
    {
        window.open('index.html','_self')
    }
    //    自定义琴键恢复初始设置按钮
    keyboardRecoverButton=new THREE.Mesh(
            new THREE.BoxGeometry(20,20,20),
            new THREE.MeshLambertMaterial({color:0xffffff,map:THREE.ImageUtils.loadTexture('ButtonPictures/keyboardRecover.png')}));
    keyboardRecoverButton.position.set(-40,40,-54);
    keyboardRecoverButton.name='keyboardRecoverButton';
    scene.add(keyboardRecoverButton);
    objects.push(keyboardRecoverButton);
    //    自定义琴键恢复初始设置
    function keyboardRecover()
    {
        initKey();
        for(i=0;i<blackKeyBoxs.length;i++)
        {
            blackKeyBoxs[i].material.map=THREE.ImageUtils.loadTexture('KeyboardPictures/null.png');
        }
        for(i=0;i<whiteKeyBoxs.length;i++)
        {
            whiteKeyBoxs[i].material.map=THREE.ImageUtils.loadTexture('KeyboardPictures/null.png');
        }
        updateBoxsPicture();
    }

    //        更新提示盒子的图片为音高
    function updateKeyBoxesOnPitch()
    {
        var i=0,j;
        if(blackKeyMode==0)
        {
            for(i = 0;i<blackKeyBoxs.length;i++)
            {
                j=101+i;
                blackKeyBoxs[i].material.map=THREE.ImageUtils.loadTexture('waterfallPitchPictures/down'+j+'.png')
            }
        }
        else
        {
            for(i = 0;i<blackKeyBoxs.length;i++)
            {
                j=101+i;
                blackKeyBoxs[i].material.map=THREE.ImageUtils.loadTexture('waterfallPitchPictures/up'+j+'.png')
            }
        }
        for(i = 0;i<whiteKeyBoxs.length;i++)
        {
            j=201+i;
            whiteKeyBoxs[i].material.map=THREE.ImageUtils.loadTexture('waterfallPitchPictures/'+j+'.png')
        }
    }
    initStavePosition();
    //    初始化五线谱位置数组
    function initStavePosition()
    {
        var i,j,k,p;
        for(i=1;i<=52;i++)
        {
            p=staveCenterPositionY+(i-22)*2;
            whiteKeyStavePositionY.push(p);
        }
        j=0;
        for(i=1;i<=36;i++)
        {
            k=i%5;
            blackKeyStavePositionY.push(whiteKeyStavePositionY[j]);
            if(k==1||k==4)j++;
            j++;
        }
    }

</script>
</body>
</html>